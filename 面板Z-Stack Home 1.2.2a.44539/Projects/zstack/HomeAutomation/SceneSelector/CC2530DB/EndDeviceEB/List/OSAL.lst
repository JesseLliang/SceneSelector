###############################################################################
#
# IAR C/C++ Compiler V9.10.1.2146 for 8051                18/Jan/2018  14:04:26
# Copyright 2004-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Components\osal\common\OSAL.c
#    Command line       =  
#        -f "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=120000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=60000) -f
#        "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Components\osal\common\OSAL.c" -D SCENE_SELECTOR_TOUCHKEY
#        -D xSCENE_SELECTOR -D ISR_KEYINTERRUPT -D
#        OSC32K_CRYSTAL_INSTALLED=FALSE -D xxHAL_PA_LNA -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D POWER_SAVING -D
#        NWK_AUTO_POLL -D xHOLD_AUTO_START -D xZTOOL_P1 -D MT_TASK -D
#        MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D
#        xZCL_EZMODE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_GROUPS -D ZCL_SCENES
#        -D ZCL_ON_OFF -D ZCL_LEVEL_CTRL -D ZCL_DIAGNOSTIC -D
#        FEATURE_SYSTEM_STATS -lC "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack
#        Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\EndDeviceEB\List\"
#        -lA "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\EndDeviceEB\List\"
#        --diag_suppress Pe001,Pa010 -o
#        "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\EndDeviceEB\Obj\"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\Add\AddSceneSelector\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\Add\AddCommon\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\Add\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\Source\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\Source\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\EndDeviceEB\List\OSAL.lst
#    Object file        =  
#        C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home
#        1.2.2a.44539\Projects\zstack\HomeAutomation\SceneSelector\CC2530DB\EndDeviceEB\Obj\OSAL.r51
#
###############################################################################

C:\Users\JC_liang\Desktop\LIFUD\√Ê∞ÂZ-Stack Home 1.2.2a.44539\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2014-11-04 15:36:27 -0800 (Tue, 04 Nov 2014) $
      4            Revision:       $Revision: 40989 $
      5          
      6            Description:    This API allows the software components in the Z-stack to be written
      7                            independently of the specifics of the operating system, kernel or tasking
      8                            environment (including control loops or connect-to-interrupt systems).
      9          
     10          
     11            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License"). You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product. Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED ìAS ISî WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include <string.h>
     47          
     48          #include "comdef.h"
     49          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     50          #include "OSAL.h"
     51          #include "OSAL_Tasks.h"
     52          #include "OSAL_Memory.h"
     53          #include "OSAL_PwrMgr.h"
     54          #include "OSAL_Clock.h"
     55          
     56          #include "OnBoard.h"
     57          
     58          /* HAL */
     59          #include "hal_drivers.h"
     60          
     61          #ifdef IAR_ARMCM3_LM
     62            #include "FreeRTOSConfig.h"
     63            #include "osal_task.h"
     64          #endif
     65          
     66          #ifdef USE_ICALL
     67            #include <ICall.h>
     68          #endif /* USE_ICALL */
     69          
     70          //####################################################################
     71          //####################################################################
     72          #include "ZDApp.h"
     73          //####################################################################
     74          //####################################################################
     75          
     76          /*********************************************************************
     77           * MACROS
     78           */
     79          
     80          /*********************************************************************
     81           * CONSTANTS
     82           */
     83          #ifdef USE_ICALL
     84          // A bit mask to use to indicate a proxy OSAL task ID.
     85          #define OSAL_PROXY_ID_FLAG       0x80
     86          #endif // USE_ICALL
     87          
     88          /*********************************************************************
     89           * TYPEDEFS
     90           */
     91          
     92          /*********************************************************************
     93           * GLOBAL VARIABLES
     94           */
     95          
     96          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     97          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     98          
     99          #ifdef USE_ICALL
    100          // OSAL event loop hook function pointer 
    101          void (*osal_eventloop_hook)(void) = NULL;
    102          #endif /* USE_ICALL */
    103          
    104          /*********************************************************************
    105           * EXTERNAL VARIABLES
    106           */
    107          
    108          /*********************************************************************
    109           * EXTERNAL FUNCTIONS
    110           */
    111          
    112          /*********************************************************************
    113           * LOCAL VARIABLES
    114           */
    115          
    116          // Index of active task

   \                                 In  segment XDATA_I, align 1, keep-with-next
    117          static uint8 activeTaskID = TASK_NO_TASK;
   \                     activeTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for activeTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    118          
    119          #ifdef USE_ICALL
    120          // Maximum number of proxy tasks
    121          #ifndef OSAL_MAX_NUM_PROXY_TASKS
    122          #define OSAL_MAX_NUM_PROXY_TASKS 2
    123          #endif // OSAL_MAX_NUM_PROXY_TASKS
    124          
    125          // ICall entity ID value used to indicate invalid value
    126          #define OSAL_INVALID_DISPATCH_ID 0xffu
    127          
    128          // Semaphore associated with OSAL RTOS thread receive queue
    129          ICall_Semaphore osal_semaphore;
    130          
    131          // Entity ID that OSAL RTOS thread has registered with
    132          ICall_EntityID osal_entity;
    133          
    134          // Last read tick count value reflected into the OSAL timer
    135          uint_least32_t osal_last_timestamp;
    136          
    137          // RTOS tick period in microseconds
    138          uint_least32_t osal_tickperiod;
    139          
    140          // Maximum timeout value in milliseconds that can be used with an RTOS timer
    141          uint_least32_t osal_max_msecs;
    142          
    143          // Timer ID for RTOS timer as backend engine for OSAL timer
    144          static ICall_TimerID osal_timerid_msec_timer;
    145          
    146          // Timer callback sequence tracking counter to handle race condition
    147          static unsigned osal_msec_timer_seq = 0;
    148          
    149          // proxy task ID map
    150          static uint8 osal_proxy_tasks[OSAL_MAX_NUM_PROXY_TASKS];
    151          
    152          // service dispatcher entity IDs corresponding to OSAL tasks
    153          static uint8 *osal_dispatch_entities;
    154          
    155          static uint8 osal_notask_entity;
    156          
    157          #endif // USE_ICALL
    158          
    159          /*********************************************************************
    160           * LOCAL FUNCTION PROTOTYPES
    161           */
    162          
    163          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 urgent );
    164          
    165          #ifdef USE_ICALL
    166          static uint8 osal_alien2proxy(ICall_EntityID entity);
    167          static ICall_EntityID osal_proxy2alien(uint8 proxyid);
    168          static uint8 osal_dispatch2id(ICall_EntityID entity);
    169          static void osal_msec_timer_cback(void *arg);
    170          #endif // USE_ICALL
    171          
    172          /*********************************************************************
    173           * HELPER FUNCTIONS
    174           */
    175          /* very ugly stub so Keil can compile */
    176          #ifdef __KEIL__
    177          char *  itoa ( int value, char * buffer, int radix )
    178          {
    179            return(buffer);
    180          }
    181          #endif
    182          
    183          /*********************************************************************
    184           * @fn      osal_strlen
    185           *
    186           * @brief
    187           *
    188           *   Calculates the length of a string.  The string must be null
    189           *   terminated.
    190           *
    191           * @param   char *pString - pointer to text string
    192           *
    193           * @return  int - number of characters
    194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    195          int osal_strlen( char *pString )
   \                     osal_strlen:
    196          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    197            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   ??strlen?relay       ; Banked call to: strlen
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    198          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    199          
    200          /*********************************************************************
    201           * @fn      osal_memcpy
    202           *
    203           * @brief
    204           *
    205           *   Generic memory copy.
    206           *
    207           *   Note: This function differs from the standard memcpy(), since
    208           *         it returns the pointer to the next destination uint8. The
    209           *         standard memcpy() returns the original destination address.
    210           *
    211           * @param   dst - destination address
    212           * @param   src - source address
    213           * @param   len - number of bytes to copy
    214           *
    215           * @return  pointer to end of destination buffer
    216           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    217          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    218          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    219            uint8 *pDst;
    220            const uint8 GENERIC *pSrc;
    221          
    222            pSrc = src;
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine6 & 0xFFFF
    223            pDst = dst;
   \                     ??CrossCallReturnLabel_56:
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   800C         SJMP    ??osal_memcpy_0
    224          
    225            while ( len-- )
    226              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000017   12....       LCALL   ?C_GPTR_LOAD
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   E9           MOV     A,R1
   \   00001C   2401         ADD     A,#0x1
   \   00001E   09           INC     R1
   \   00001F   E4           CLR     A
   \   000020   3A           ADDC    A,R2
   \   000021   FA           MOV     R2,A
   \   000022   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   000023   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000026   70EF         JNZ     ??osal_memcpy_1
    227          
    228            return ( pDst );
   \   000028   02....       LJMP    ?Subroutine1 & 0xFFFF
    229          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   EC           MOV     A,R4
   \   000001   FE           MOV     R6,A
   \   000002   ED           MOV     A,R5
   \   000003   FF           MOV     R7,A
   \   000004   EE           MOV     A,R6
   \   000005   24FF         ADD     A,#-0x1
   \   000007   1C           DEC     R4
   \   000008   EF           MOV     A,R7
   \   000009   34FF         ADDC    A,#-0x1
   \   00000B   FD           MOV     R5,A
   \   00000C   EE           MOV     A,R6
   \   00000D   4F           ORL     A,R7
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004                REQUIRE ??Subroutine22_0
   \   000004                ; // Fall through to label ??Subroutine22_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine22_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine26_0
   \   000003                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    230          
    231          /*********************************************************************
    232           * @fn      osal_revmemcpy
    233           *
    234           * @brief   Generic reverse memory copy.  Starts at the end of the
    235           *   source buffer, by taking the source address pointer and moving
    236           *   pointer ahead "len" bytes, then decrementing the pointer.
    237           *
    238           *   Note: This function differs from the standard memcpy(), since
    239           *         it returns the pointer to the next destination uint8. The
    240           *         standard memcpy() returns the original destination address.
    241           *
    242           * @param   dst - destination address
    243           * @param   src - source address
    244           * @param   len - number of bytes to copy
    245           *
    246           * @return  pointer to end of destination buffer
    247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          void *osal_revmemcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_revmemcpy:
    249          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    250            uint8 *pDst;
    251            const uint8 GENERIC *pSrc;
    252          
    253            pSrc = src;
    254            pSrc += (len-1);
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000011   E9           MOV     A,R1
   \   000012   2C           ADD     A,R4
   \   000013   F9           MOV     R1,A
   \   000014   EA           MOV     A,R2
   \   000015   3D           ADDC    A,R5
   \   000016   FA           MOV     R2,A
   \   000017   E9           MOV     A,R1
   \   000018   24FF         ADD     A,#-0x1
   \   00001A   19           DEC     R1
   \   00001B   EA           MOV     A,R2
   \   00001C   34FF         ADDC    A,#-0x1
   \   00001E   FA           MOV     R2,A
    255            pDst = dst;
   \   00001F   8E82         MOV     DPL,R6
   \   000021   8F83         MOV     DPH,R7
   \   000023   800D         SJMP    ??osal_revmemcpy_0
    256          
    257            while ( len-- )
    258              *pDst++ = *pSrc--;
   \                     ??osal_revmemcpy_1:
   \   000025   12....       LCALL   ?C_GPTR_LOAD
   \   000028   F0           MOVX    @DPTR,A
   \   000029   E9           MOV     A,R1
   \   00002A   24FF         ADD     A,#-0x1
   \   00002C   19           DEC     R1
   \   00002D   EA           MOV     A,R2
   \   00002E   34FF         ADDC    A,#-0x1
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \                     ??osal_revmemcpy_0:
   \   000032   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000035   70EE         JNZ     ??osal_revmemcpy_1
    259          
    260            return ( pDst );
   \   000037   02....       LJMP    ?Subroutine1 & 0xFFFF
    261          }
    262          
    263          /*********************************************************************
    264           * @fn      osal_memdup
    265           *
    266           * @brief   Allocates a buffer [with osal_mem_alloc()] and copies
    267           *          the src buffer into the newly allocated space.
    268           *
    269           * @param   src - source address
    270           * @param   len - number of bytes to copy
    271           *
    272           * @return  pointer to the new allocated buffer, or NULL if
    273           *          allocation problem.
    274           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    275          void *osal_memdup( const void GENERIC *src, unsigned int len )
   \                     osal_memdup:
    276          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V4,R1
   \   000007   8A..         MOV     ?V5,R2
   \   000009   8B..         MOV     ?V6,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    277            uint8 *pDst;
    278          
    279            pDst = osal_mem_alloc( len );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000016   8A..         MOV     ?V0,R2
   \   000018   8B..         MOV     ?V1,R3
    280            if ( pDst )
   \   00001A   EA           MOV     A,R2
   \   00001B   45..         ORL     A,?V1
   \   00001D   6011         JZ      ??osal_memdup_0
    281            {
    282              VOID osal_memcpy( pDst, src, len );
   \   00001F                ; Setup parameters for call to function osal_memcpy
   \   00001F   78..         MOV     R0,#?V4
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000024   EE           MOV     A,R6
   \   000025   FC           MOV     R4,A
   \   000026   EF           MOV     A,R7
   \   000027   FD           MOV     R5,A
   \   000028   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
    283            }
    284          
    285            return ( (void *)pDst );
   \                     ??osal_memdup_0:
   \   000030   AA..         MOV     R2,?V0
   \   000032   AB..         MOV     R3,?V1
   \   000034   7F07         MOV     R7,#0x7
   \   000036   02....       LJMP    ?BANKED_LEAVE_XDATA
    286          }
    287          
    288          /*********************************************************************
    289           * @fn      osal_memcmp
    290           *
    291           * @brief
    292           *
    293           *   Generic memory compare.
    294           *
    295           * @param   src1 - source 1 addrexx
    296           * @param   src2 - source 2 address
    297           * @param   len - number of bytes to compare
    298           *
    299           * @return  TRUE - same, FALSE - different
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
    302          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
    303            const uint8 GENERIC *pSrc1;
    304            const uint8 GENERIC *pSrc2;
    305          
    306            pSrc1 = src1;
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   8B..         MOV     ?V2,R3
    307            pSrc2 = src2;
   \   00000B   7413         MOV     A,#0x13
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V4,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V5,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V6,A
    308          
    309            while ( len-- )
   \                     ??osal_memcmp_0:
   \   00001B   EC           MOV     A,R4
   \   00001C   F8           MOV     R0,A
   \   00001D   ED           MOV     A,R5
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   24FF         ADD     A,#-0x1
   \   000022   1C           DEC     R4
   \   000023   E9           MOV     A,R1
   \   000024   34FF         ADDC    A,#-0x1
   \   000026   FD           MOV     R5,A
   \   000027   E8           MOV     A,R0
   \   000028   49           ORL     A,R1
   \   000029   6037         JZ      ??osal_memcmp_1
    310            {
    311              if( *pSrc1++ != *pSrc2++ )
   \   00002B   A9..         MOV     R1,?V0
   \   00002D   AA..         MOV     R2,?V1
   \   00002F   AB..         MOV     R3,?V2
   \   000031   E9           MOV     A,R1
   \   000032   2401         ADD     A,#0x1
   \   000034   F5..         MOV     ?V0,A
   \   000036   E4           CLR     A
   \   000037   3A           ADDC    A,R2
   \   000038   F5..         MOV     ?V1,A
   \   00003A   85....       MOV     ?V8,?V4
   \   00003D   85....       MOV     ?V9,?V5
   \   000040   85....       MOV     ?V10,?V6
   \   000043   E5..         MOV     A,?V4
   \   000045   2401         ADD     A,#0x1
   \   000047   F5..         MOV     ?V4,A
   \   000049   E4           CLR     A
   \   00004A   35..         ADDC    A,?V5
   \   00004C   F5..         MOV     ?V5,A
   \   00004E   12....       LCALL   ?C_GPTR_LOAD
   \   000051   F8           MOV     R0,A
   \   000052   A9..         MOV     R1,?V8
   \   000054   AA..         MOV     R2,?V9
   \   000056   AB..         MOV     R3,?V10
   \   000058   12....       LCALL   ?C_GPTR_LOAD
   \   00005B   68           XRL     A,R0
   \   00005C   60BD         JZ      ??osal_memcmp_0
    312                return FALSE;
   \   00005E   7900         MOV     R1,#0x0
   \   000060   8002         SJMP    ??osal_memcmp_2
    313            }
    314            return TRUE;
   \                     ??osal_memcmp_1:
   \   000062   7901         MOV     R1,#0x1
   \                     ??osal_memcmp_2:
   \   000064   7F0B         MOV     R7,#0xb
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
    315          }
    316          
    317          
    318          /*********************************************************************
    319           * @fn      osal_memset
    320           *
    321           * @brief
    322           *
    323           *   Set memory buffer to value.
    324           *
    325           * @param   dest - pointer to buffer
    326           * @param   value - what to set each uint8 of the message
    327           * @param   size - how big
    328           *
    329           * @return  pointer to destination buffer
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    332          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    333            return memset( dest, value, len );
   \   000007                ; Setup parameters for call to function memset
   \   000007   8C..         MOV     ?V0,R4
   \   000009   8D..         MOV     ?V1,R5
   \   00000B   78..         MOV     R0,#?V0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   EE           MOV     A,R6
   \   000011   FC           MOV     R4,A
   \   000012   7D00         MOV     R5,#0x0
   \   000014   12....       LCALL   ??memset?relay       ; Banked call to: memset
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001C   02....       LJMP    ?Subroutine2 & 0xFFFF
    334          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    335          
    336          /*********************************************************************
    337           * @fn      osal_build_uint16
    338           *
    339           * @brief
    340           *
    341           *   Build a uint16 out of 2 bytes (0 then 1).
    342           *
    343           * @param   swapped - 0 then 1
    344           *
    345           * @return  uint16
    346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    347          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    348          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    349            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   C8           XCH     A,R0
   \   00000F   F9           MOV     R1,A
   \   000010   EC           MOV     A,R4
   \   000011   28           ADD     A,R0
   \   000012   FA           MOV     R2,A
   \   000013   E4           CLR     A
   \   000014   39           ADDC    A,R1
   \   000015   FB           MOV     R3,A
   \   000016   02....       LJMP    ?Subroutine0 & 0xFFFF
    350          }
    351          
    352          /*********************************************************************
    353           * @fn      osal_build_uint32
    354           *
    355           * @brief
    356           *
    357           *   Build a uint32 out of sequential bytes.
    358           *
    359           * @param   swapped - sequential bytes
    360           * @param   len - number of bytes in the uint8 array
    361           *
    362           * @return  uint32
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    365          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    366            if ( len == 2 )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   F5..         MOV     ?V5,A
   \   000011   F5..         MOV     ?V6,A
   \   000013   F5..         MOV     ?V7,A
   \   000015   7402         MOV     A,#0x2
   \   000017   6E           XRL     A,R6
   \   000018   7005         JNZ     ??osal_build_uint32_0
    367              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00001A   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00001D   8047         SJMP    ??osal_build_uint32_1
    368            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   00001F   7403         MOV     A,#0x3
   \   000021   6E           XRL     A,R6
   \   000022   7012         JNZ     ??osal_build_uint32_2
    369              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   000024   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000027   12....       LCALL   ?L_SHL
   \   00002A   78..         MOV     R0,#?V4
   \   00002C   79..         MOV     R1,#?V0
   \   00002E   12....       LCALL   ?L_ADD
   \   000031   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000034   8030         SJMP    ??osal_build_uint32_1
    370            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000036   7404         MOV     A,#0x4
   \   000038   6E           XRL     A,R6
   \   000039   7037         JNZ     ??osal_build_uint32_3
    371              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00003B   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00003E   12....       LCALL   ?L_SHL
   \   000041   78..         MOV     R0,#?V4
   \   000043   79..         MOV     R1,#?V0
   \   000045   12....       LCALL   ?L_ADD
   \   000048   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?L_SHL
   \   000050   78..         MOV     R0,#?V4
   \   000052   79..         MOV     R1,#?V0
   \   000054   12....       LCALL   ?L_ADD
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F5..         MOV     ?V0,A
   \   000061   E4           CLR     A
   \   000062   F5..         MOV     ?V2,A
   \   000064   7418         MOV     A,#0x18
   \                     ??osal_build_uint32_1:
   \   000066   78..         MOV     R0,#?V0
   \   000068   12....       LCALL   ?L_SHL
   \   00006B   78..         MOV     R0,#?V4
   \   00006D   79..         MOV     R1,#?V0
   \   00006F   12....       LCALL   ?L_ADD
    372            else
    373              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_3:
   \   000072   AA..         MOV     R2,?V4
   \   000074   AB..         MOV     R3,?V5
   \   000076   AC..         MOV     R4,?V6
   \   000078   AD..         MOV     R5,?V7
   \   00007A   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    374          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0,A
   \   000009   E4           CLR     A
   \   00000A   F5..         MOV     ?V1,A
   \   00000C   7410         MOV     A,#0x10
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F5..         MOV     ?V0,A
   \   000004   E4           CLR     A
   \   000005   F5..         MOV     ?V1,A
   \   000007   F5..         MOV     ?V2,A
   \   000009   F5..         MOV     ?V3,A
   \   00000B   7408         MOV     A,#0x8
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    375          
    376          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    377          /*********************************************************************
    378           * @fn      _ltoa
    379           *
    380           * @brief
    381           *
    382           *   convert a long unsigned int to a string.
    383           *
    384           * @param  l - long to convert
    385           * @param  buf - buffer to convert to
    386           * @param  radix - 10 dec, 16 hex
    387           *
    388           * @return  pointer to buffer
    389           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    390          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    391          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 33
   \   000005   74DF         MOV     A,#-0x21
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   8A..         MOV     ?V8,R2
   \   000014   8B..         MOV     ?V9,R3
   \   000016   8C..         MOV     ?V10,R4
   \   000018   8D..         MOV     ?V11,R5
    392          #if defined (__TI_COMPILER_VERSION)
    393            return ( (unsigned char*)ltoa( l, (char *)buf ) );
    394          #elif defined( __GNUC__ )
    395            return ( (char*)ltoa( l, buf, radix ) );
    396          #else
    397            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00001A   90....       MOV     DPTR,#`?<Constant "">`
   \   00001D   7403         MOV     A,#0x3
   \   00001F   12....       LCALL   ?XSTACK_DISP102_8
   \   000022   740A         MOV     A,#0xa
   \   000024   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000027   90....       MOV     DPTR,#`?<Constant "">_1`
   \   00002A   740A         MOV     A,#0xa
   \   00002C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00002F   90....       MOV     DPTR,#`?<Constant "">_2`
   \   000032   740A         MOV     A,#0xa
   \   000034   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    398            unsigned short num1, num2, num3;
    399            unsigned char i;
    400          
    401            buf[0] = '\0';
   \   000037   7439         MOV     A,#0x39
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00003F   E4           CLR     A
   \   000040   F0           MOVX    @DPTR,A
    402          
    403            if ( radix == 10 )
   \   000041   04           INC     A
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   74..         MOV     A,#`?<Constant "0">` & 0xff
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   74..         MOV     A,#(`?<Constant "0">` >> 8) & 0xff
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   640A         XRL     A,#0xa
   \   000055   6003         JZ      $+5
   \   000057   02....       LJMP    ??_ltoa_0 & 0xFFFF
    404            {
    405              num1 = l % 10000;
   \   00005A   8A..         MOV     ?V0,R2
   \   00005C   8B..         MOV     ?V1,R3
   \   00005E   85....       MOV     ?V2,?V10
   \   000061   85....       MOV     ?V3,?V11
   \   000064   90....       MOV     DPTR,#__Constant_2710
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?L_MOV_X
   \   00006C   78..         MOV     R0,#?V0
   \   00006E   79..         MOV     R1,#?V4
   \   000070   12....       LCALL   ?UL_DIV_MOD
   \   000073   85....       MOV     ?V0,?V4
   \   000076   85....       MOV     ?V1,?V5
    406              num2 = (l / 10000) % 10000;
   \   000079   8A..         MOV     ?V4,R2
   \   00007B   8B..         MOV     ?V5,R3
   \   00007D   85....       MOV     ?V6,?V10
   \   000080   85....       MOV     ?V7,?V11
   \   000083   90....       MOV     DPTR,#__Constant_2710
   \   000086   78..         MOV     R0,#?V12
   \   000088   12....       LCALL   ?L_MOV_X
   \   00008B   78..         MOV     R0,#?V4
   \   00008D   79..         MOV     R1,#?V12
   \   00008F   12....       LCALL   ?UL_DIV_MOD
   \   000092   90....       MOV     DPTR,#__Constant_2710
   \   000095   78..         MOV     R0,#?V12
   \   000097   12....       LCALL   ?L_MOV_X
   \   00009A   78..         MOV     R0,#?V4
   \   00009C   79..         MOV     R1,#?V12
   \   00009E   12....       LCALL   ?UL_DIV_MOD
   \   0000A1   AE..         MOV     R6,?V12
   \   0000A3   AF..         MOV     R7,?V13
    407              num3 = (unsigned short)(l / 100000000);
   \   0000A5   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000A8   78..         MOV     R0,#?V4
   \   0000AA   12....       LCALL   ?L_MOV_X
   \   0000AD   78..         MOV     R0,#?V8
   \   0000AF   79..         MOV     R1,#?V4
   \   0000B1   12....       LCALL   ?UL_DIV_MOD
   \   0000B4   85....       MOV     ?V2,?V8
   \   0000B7   85....       MOV     ?V3,?V9
    408          
    409              if (num3) _itoa(num3, tmp3, 10);
   \   0000BA   E5..         MOV     A,?V2
   \   0000BC   45..         ORL     A,?V3
   \   0000BE   600E         JZ      ??_ltoa_1
   \   0000C0                ; Setup parameters for call to function _itoa
   \   0000C0   790A         MOV     R1,#0xa
   \   0000C2   7417         MOV     A,#0x17
   \   0000C4   12....       LCALL   ?XSTACK_DISP102_8
   \   0000C7   AA..         MOV     R2,?V2
   \   0000C9   AB..         MOV     R3,?V3
   \   0000CB   12....       LCALL   ??_itoa?relay        ; Banked call to: _itoa
    410              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_1:
   \   0000CE   EE           MOV     A,R6
   \   0000CF   4F           ORL     A,R7
   \   0000D0   600E         JZ      ??_ltoa_2
   \   0000D2                ; Setup parameters for call to function _itoa
   \   0000D2   790A         MOV     R1,#0xa
   \   0000D4   740D         MOV     A,#0xd
   \   0000D6   12....       LCALL   ?XSTACK_DISP102_8
   \   0000D9   EE           MOV     A,R6
   \   0000DA   FA           MOV     R2,A
   \   0000DB   EF           MOV     A,R7
   \   0000DC   FB           MOV     R3,A
   \   0000DD   12....       LCALL   ??_itoa?relay        ; Banked call to: _itoa
    411              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_2:
   \   0000E0   E5..         MOV     A,?V0
   \   0000E2   45..         ORL     A,?V1
   \   0000E4   600E         JZ      ??_ltoa_3
   \   0000E6                ; Setup parameters for call to function _itoa
   \   0000E6   790A         MOV     R1,#0xa
   \   0000E8   7403         MOV     A,#0x3
   \   0000EA   12....       LCALL   ?XSTACK_DISP102_8
   \   0000ED   AA..         MOV     R2,?V0
   \   0000EF   AB..         MOV     R3,?V1
   \   0000F1   12....       LCALL   ??_itoa?relay        ; Banked call to: _itoa
    412          
    413              if (num3)
   \                     ??_ltoa_3:
   \   0000F4   E5..         MOV     A,?V2
   \   0000F6   45..         ORL     A,?V3
   \   0000F8   6038         JZ      ??_ltoa_4
    414              {
    415                strcpy((char*)buf, (char const*)tmp3);
   \   0000FA                ; Setup parameters for call to function strcpy
   \   0000FA   7417         MOV     A,#0x17
   \   0000FC   12....       LCALL   ?XSTACK_DISP102_8
   \   0000FF   7439         MOV     A,#0x39
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000107   12....       LCALL   ??strcpy?relay       ; Banked call to: strcpy
    416                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \   00010A   75..00       MOV     ?V4,#0x0
   \   00010D   8013         SJMP    ??_ltoa_5
    417                  strcat((char*)buf, "0");
   \                     ??_ltoa_6:
   \   00010F                ; Setup parameters for call to function strcat
   \   00010F   7401         MOV     A,#0x1
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00011D   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
   \   000120   05..         INC     ?V4
   \                     ??_ltoa_5:
   \   000122   85....       MOV     ?V6,?V4
   \   000125                ; Setup parameters for call to function strlen
   \   000125   740D         MOV     A,#0xd
   \   000127   12....       LCALL   ?XSTACK_DISP101_8
   \   00012A   12....       LCALL   ??strlen?relay       ; Banked call to: strlen
   \   00012D   12....       LCALL   ?Subroutine19 & 0xFFFF
    418              }
   \                     ??CrossCallReturnLabel_23:
   \   000130   40DD         JC      ??_ltoa_6
    419              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_4:
   \   000132                ; Setup parameters for call to function strcat
   \   000132   740D         MOV     A,#0xd
   \   000134   12....       LCALL   ?XSTACK_DISP102_8
   \   000137   7439         MOV     A,#0x39
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00013F   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
    420              if (num3 || num2)
   \   000142   E5..         MOV     A,?V2
   \   000144   45..         ORL     A,?V3
   \   000146   7004         JNZ     ??_ltoa_7
   \   000148   EE           MOV     A,R6
   \   000149   4F           ORL     A,R7
   \   00014A   6028         JZ      ??_ltoa_8
    421              {
    422                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_7:
   \   00014C   75..00       MOV     ?V4,#0x0
   \   00014F   8013         SJMP    ??_ltoa_9
    423                  strcat((char*)buf, "0");
   \                     ??_ltoa_10:
   \   000151                ; Setup parameters for call to function strcat
   \   000151   7401         MOV     A,#0x1
   \   000153   12....       LCALL   ?XSTACK_DISP0_8
   \   000156   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00015F   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
   \   000162   05..         INC     ?V4
   \                     ??_ltoa_9:
   \   000164   85....       MOV     ?V6,?V4
   \   000167                ; Setup parameters for call to function strlen
   \   000167   7403         MOV     A,#0x3
   \   000169   12....       LCALL   ?XSTACK_DISP101_8
   \   00016C   12....       LCALL   ??strlen?relay       ; Banked call to: strlen
   \   00016F   12....       LCALL   ?Subroutine19 & 0xFFFF
    424              }
   \                     ??CrossCallReturnLabel_24:
   \   000172   40DD         JC      ??_ltoa_10
    425              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_8:
   \   000174                ; Setup parameters for call to function strcat
   \   000174   7403         MOV     A,#0x3
   \   000176   12....       LCALL   ?XSTACK_DISP102_8
   \   000179   7439         MOV     A,#0x39
   \   00017B   12....       LCALL   ?XSTACK_DISP0_8
   \   00017E   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000181   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
    426              if (!num3 && !num2 && !num1)
   \   000184   E5..         MOV     A,?V2
   \   000186   45..         ORL     A,?V3
   \   000188   7007         JNZ     ??_ltoa_11
   \   00018A   EE           MOV     A,R6
   \   00018B   4F           ORL     A,R7
   \   00018C   7003         JNZ     $+5
   \   00018E   02....       LJMP    ??_ltoa_12 & 0xFFFF
    427                strcpy((char*)buf, "0");
    428            }
    429            else if ( radix == 16 )
    430            {
    431              num1 = l & 0x0000FFFF;
    432              num2 = l >> 16;
    433          
    434              if (num2) _itoa(num2, tmp2, 16);
    435              if (num1) _itoa(num1, tmp1, 16);
    436          
    437              if (num2)
    438              {
    439                strcpy((char*)buf,(char const*)tmp2);
    440                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    441                  strcat((char*)buf, "0");
    442              }
    443              strcat((char*)buf, (char const*)tmp1);
    444              if (!num2 && !num1)
    445                strcpy((char*)buf, "0");
    446            }
    447            else
    448              return NULL;
    449          
    450            return buf;
   \                     ??_ltoa_11:
   \   000191   7439         MOV     A,#0x39
   \   000193   12....       LCALL   ?XSTACK_DISP0_8
   \   000196   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000199   7421         MOV     A,#0x21
   \   00019B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00019E   7F10         MOV     R7,#0x10
   \   0001A0   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??_ltoa_0:
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   6410         XRL     A,#0x10
   \   0001A6   6003         JZ      $+5
   \   0001A8   02....       LJMP    ??_ltoa_13 & 0xFFFF
   \   0001AB   8A..         MOV     ?V0,R2
   \   0001AD   8B..         MOV     ?V1,R3
   \   0001AF   7410         MOV     A,#0x10
   \   0001B1   78..         MOV     R0,#?V8
   \   0001B3   12....       LCALL   ?UL_SHR
   \   0001B6   AE..         MOV     R6,?V8
   \   0001B8   AF..         MOV     R7,?V9
   \   0001BA   EE           MOV     A,R6
   \   0001BB   4F           ORL     A,R7
   \   0001BC   600E         JZ      ??_ltoa_14
   \   0001BE                ; Setup parameters for call to function _itoa
   \   0001BE   7910         MOV     R1,#0x10
   \   0001C0   740D         MOV     A,#0xd
   \   0001C2   12....       LCALL   ?XSTACK_DISP102_8
   \   0001C5   EE           MOV     A,R6
   \   0001C6   FA           MOV     R2,A
   \   0001C7   EF           MOV     A,R7
   \   0001C8   FB           MOV     R3,A
   \   0001C9   12....       LCALL   ??_itoa?relay        ; Banked call to: _itoa
   \                     ??_ltoa_14:
   \   0001CC   E5..         MOV     A,?V0
   \   0001CE   45..         ORL     A,?V1
   \   0001D0   600E         JZ      ??_ltoa_15
   \   0001D2                ; Setup parameters for call to function _itoa
   \   0001D2   7910         MOV     R1,#0x10
   \   0001D4   7403         MOV     A,#0x3
   \   0001D6   12....       LCALL   ?XSTACK_DISP102_8
   \   0001D9   AA..         MOV     R2,?V0
   \   0001DB   AB..         MOV     R3,?V1
   \   0001DD   12....       LCALL   ??_itoa?relay        ; Banked call to: _itoa
   \                     ??_ltoa_15:
   \   0001E0   EE           MOV     A,R6
   \   0001E1   4F           ORL     A,R7
   \   0001E2   6049         JZ      ??_ltoa_16
   \   0001E4                ; Setup parameters for call to function strcpy
   \   0001E4   740D         MOV     A,#0xd
   \   0001E6   12....       LCALL   ?XSTACK_DISP102_8
   \   0001E9   7439         MOV     A,#0x39
   \   0001EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EE   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0001F1   12....       LCALL   ??strcpy?relay       ; Banked call to: strcpy
   \   0001F4   75..00       MOV     ?V4,#0x0
   \   0001F7   8013         SJMP    ??_ltoa_17
   \                     ??_ltoa_18:
   \   0001F9                ; Setup parameters for call to function strcat
   \   0001F9   7401         MOV     A,#0x1
   \   0001FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FE   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000201   12....       LCALL   ?XSTACK_DISP0_8
   \   000204   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000207   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
   \   00020A   05..         INC     ?V4
   \                     ??_ltoa_17:
   \   00020C   85....       MOV     ?V2,?V4
   \   00020F                ; Setup parameters for call to function strlen
   \   00020F   7403         MOV     A,#0x3
   \   000211   12....       LCALL   ?XSTACK_DISP101_8
   \   000214   12....       LCALL   ??strlen?relay       ; Banked call to: strlen
   \   000217   8A..         MOV     ?V6,R2
   \   000219   8B..         MOV     ?V7,R3
   \   00021B   7404         MOV     A,#0x4
   \   00021D   C3           CLR     C
   \   00021E   95..         SUBB    A,?V6
   \   000220   F8           MOV     R0,A
   \   000221   E4           CLR     A
   \   000222   95..         SUBB    A,?V7
   \   000224   F9           MOV     R1,A
   \   000225   C3           CLR     C
   \   000226   E5..         MOV     A,?V2
   \   000228   98           SUBB    A,R0
   \   000229   E4           CLR     A
   \   00022A   99           SUBB    A,R1
   \   00022B   40CC         JC      ??_ltoa_18
   \                     ??_ltoa_16:
   \   00022D                ; Setup parameters for call to function strcat
   \   00022D   7403         MOV     A,#0x3
   \   00022F   12....       LCALL   ?XSTACK_DISP102_8
   \   000232   7439         MOV     A,#0x39
   \   000234   12....       LCALL   ?XSTACK_DISP0_8
   \   000237   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00023A   12....       LCALL   ??strcat?relay       ; Banked call to: strcat
   \   00023D   EE           MOV     A,R6
   \   00023E   4F           ORL     A,R7
   \   00023F   6003         JZ      $+5
   \   000241   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \                     ??_ltoa_12:
   \   000244   E5..         MOV     A,?V0
   \   000246   45..         ORL     A,?V1
   \   000248   6003         JZ      $+5
   \   00024A   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \   00024D                ; Setup parameters for call to function strcpy
   \   00024D   7401         MOV     A,#0x1
   \   00024F   12....       LCALL   ?XSTACK_DISP0_8
   \   000252   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000255   12....       LCALL   ?XSTACK_DISP0_8
   \   000258   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00025B   12....       LCALL   ??strcpy?relay       ; Banked call to: strcpy
   \   00025E   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \                     ??_ltoa_13:
   \   000261   7A00         MOV     R2,#0x0
   \   000263   7B00         MOV     R3,#0x0
   \   000265   02....       LJMP    ??CrossCallReturnLabel_49 & 0xFFFF
    451          #endif
    452          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   7404         MOV     A,#0x4
   \   000006   C3           CLR     C
   \   000007   95..         SUBB    A,?V8
   \   000009   F8           MOV     R0,A
   \   00000A   E4           CLR     A
   \   00000B   95..         SUBB    A,?V9
   \   00000D   F9           MOV     R1,A
   \   00000E   C3           CLR     C
   \   00000F   E5..         MOV     A,?V6
   \   000011   98           SUBB    A,R0
   \   000012   E4           CLR     A
   \   000013   99           SUBB    A,R1
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   7439         MOV     A,#0x39
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    453          #endif // !defined(ZBIT) && !defined(ZBIT2)
    454          
    455          /*********************************************************************
    456           * @fn        osal_rand
    457           *
    458           * @brief    Random number generator
    459           *
    460           * @param   none
    461           *
    462           * @return  uint16 - new random number
    463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    464          uint16 osal_rand( void )
   \                     osal_rand:
    465          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    466            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   ??Onboard_rand?relay ; Banked call to: Onboard_rand
   \   000007   80..         SJMP    ?Subroutine0
    467          }
    468          
    469          /*********************************************************************
    470           * API FUNCTIONS
    471           *********************************************************************/
    472          
    473          #ifdef USE_ICALL
    474          /*********************************************************************
    475           * @fn      osal_prepare_svc_enroll
    476           *
    477           * @brief   Initialize data structures that map OSAL task ids to
    478           *          ICall entity ids.
    479           *
    480           * @param   none
    481           *
    482           * @return  none
    483           */
    484          static void osal_prepare_svc_enroll(void)
    485          {
    486            osal_dispatch_entities = (uint8 *) osal_mem_alloc(tasksCnt * 2);
    487            osal_memset(osal_dispatch_entities, OSAL_INVALID_DISPATCH_ID, tasksCnt * 2);
    488            osal_memset(osal_proxy_tasks, OSAL_INVALID_DISPATCH_ID,
    489                        OSAL_MAX_NUM_PROXY_TASKS);
    490          }
    491          
    492          /*********************************************************************
    493           * @fn      osal_enroll_dispatchid
    494           *
    495           * @brief   Map a task id to an ICall entity id for messaging in
    496           *          both directions (sending and receiving).
    497           *
    498           * @param   taskid       OSAL task id
    499           * @param   dispatchid   ICall entity id
    500           *
    501           * @return  none
    502           */
    503          void osal_enroll_dispatchid(uint8 taskid, ICall_EntityID dispatchid)
    504          {
    505            osal_dispatch_entities[taskid] = dispatchid;
    506            osal_dispatch_entities[tasksCnt + taskid] = dispatchid;
    507          }
    508          
    509          /*********************************************************************
    510           * @fn      osal_enroll_senderid
    511           *
    512           * @brief   Map a task id to an ICall entity id, which shall be used
    513           *          just for sending a message from an OSAL task.
    514           *          Note that osal_enroll_dispatchid() must never be called
    515           *          with the same OSAL task id used in this function call.
    516           *          However, it is OK to call osal_enroll_dispatchid()
    517           *          with the same ICall entity id and a different OSAL task id.
    518           *
    519           * @param   taskid       OSAL task id
    520           * @param   dispatchid   ICall entity id
    521           *
    522           * @return  none
    523           */
    524          void osal_enroll_senderid(uint8 taskid, ICall_EntityID dispatchid)
    525          {
    526            osal_dispatch_entities[tasksCnt + taskid] = dispatchid;
    527          }
    528          
    529          /*********************************************************************
    530           * @fn      osal_enroll_notasksender
    531           *
    532           * @brief   Map no task id to an ICall entity id, which shall be used
    533           *          just for sending a message from non-OSAL task.
    534           *
    535           * @param   dispatchid   ICall entity id
    536           *
    537           * @return  none
    538           */
    539          void osal_enroll_notasksender(ICall_EntityID dispatchid)
    540          {
    541            osal_notask_entity = dispatchid;
    542          }
    543          #endif /* USE_ICALL */
    544          
    545          /*********************************************************************
    546           * @fn      osal_msg_allocate
    547           *
    548           * @brief
    549           *
    550           *    This function is called by a task to allocate a message buffer
    551           *    into which the task will encode the particular message it wishes
    552           *    to send.  This common buffer scheme is used to strictly limit the
    553           *    creation of message buffers within the system due to RAM size
    554           *    limitations on the microprocessor.   Note that all message buffers
    555           *    are a fixed size (at least initially).  The parameter len is kept
    556           *    in case a message pool with varying fixed message sizes is later
    557           *    created (for example, a pool of message buffers of size LARGE,
    558           *    MEDIUM and SMALL could be maintained and allocated based on request
    559           *    from the tasks).
    560           *
    561           *
    562           * @param   uint8 len  - wanted buffer length
    563           *
    564           *
    565           * @return  pointer to allocated buffer or NULL if allocation failed.
    566           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    567          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    568          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    569            osal_msg_hdr_t *hdr;
    570          
    571            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   603D         JZ      ??osal_msg_allocate_0
    572              return ( NULL );
    573          
    574            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   EE           MOV     A,R6
   \   00000E   2405         ADD     A,#0x5
   \   000010   FA           MOV     R2,A
   \   000011   E4           CLR     A
   \   000012   3F           ADDC    A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000017   8A..         MOV     ?V0,R2
   \   000019   8B..         MOV     ?V1,R3
   \   00001B   A8..         MOV     R0,?V0
   \   00001D   A9..         MOV     R1,?V1
    575            if ( hdr )
   \   00001F   E8           MOV     A,R0
   \   000020   49           ORL     A,R1
   \   000021   6027         JZ      ??osal_msg_allocate_0
    576            {
    577              hdr->next = NULL;
   \   000023   8882         MOV     DPL,R0
   \   000025   8983         MOV     DPH,R1
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   F0           MOVX    @DPTR,A
    578              hdr->len = len;
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   EE           MOV     A,R6
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   EF           MOV     A,R7
   \   000035   F0           MOVX    @DPTR,A
    579              hdr->dest_id = TASK_NO_TASK;
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   74FF         MOV     A,#-0x1
   \   000040   F0           MOVX    @DPTR,A
    580              return ( (uint8 *) (hdr + 1) );
   \   000041   E8           MOV     A,R0
   \   000042   2405         ADD     A,#0x5
   \   000044   FA           MOV     R2,A
   \   000045   E4           CLR     A
   \   000046   39           ADDC    A,R1
   \   000047   FB           MOV     R3,A
   \   000048   8004         SJMP    ??osal_msg_allocate_1
    581            }
    582            else
    583              return ( NULL );
   \                     ??osal_msg_allocate_0:
   \   00004A   7A00         MOV     R2,#0x0
   \   00004C   7B00         MOV     R3,#0x0
   \                     ??osal_msg_allocate_1:
   \   00004E   02....       LJMP    ?Subroutine2 & 0xFFFF
    584          }
    585          
    586          /*********************************************************************
    587           * @fn      osal_msg_deallocate
    588           *
    589           * @brief
    590           *
    591           *    This function is used to deallocate a message buffer. This function
    592           *    is called by a task (or processing element) after it has finished
    593           *    processing a received message.
    594           *
    595           *
    596           * @param   uint8 *msg_ptr - pointer to new message buffer
    597           *
    598           * @return  SUCCESS, INVALID_MSG_POINTER
    599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    600          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    601          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    602            uint8 *x;
    603          
    604            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   7004         JNZ     ??osal_msg_deallocate_0
    605              return ( INVALID_MSG_POINTER );
   \   000008   7905         MOV     R1,#0x5
   \   00000A   8016         SJMP    ??osal_msg_deallocate_1
    606          
    607            // don't deallocate queued buffer
    608            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_0:
   \   00000C   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00000F   6004         JZ      ??osal_msg_deallocate_2
    609              return ( MSG_BUFFER_NOT_AVAIL );
   \   000011   7904         MOV     R1,#0x4
   \   000013   800D         SJMP    ??osal_msg_deallocate_1
    610          
    611            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    612          
    613            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_2:
   \   000015                ; Setup parameters for call to function osal_mem_free
   \   000015   EA           MOV     A,R2
   \   000016   24FB         ADD     A,#-0x5
   \   000018   FA           MOV     R2,A
   \   000019   EB           MOV     A,R3
   \   00001A   34FF         ADDC    A,#-0x1
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
    614          
    615            return ( SUCCESS );
   \   000020   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_1:
   \   000022                REQUIRE ?Subroutine0
   \   000022                ; // Fall through to label ?Subroutine0
    616          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   EA           MOV     A,R2
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F4           CPL     A
   \   00000C   22           RET
    617          
    618          /*********************************************************************
    619           * @fn      osal_msg_send
    620           *
    621           * @brief
    622           *
    623           *    This function is called by a task to send a command message to
    624           *    another task or processing element.  The sending_task field must
    625           *    refer to a valid task, since the task ID will be used
    626           *    for the response message.  This function will also set a message
    627           *    ready event in the destination tasks event list.
    628           *
    629           *
    630           * @param   uint8 destination_task - Send msg to Task ID
    631           * @param   uint8 *msg_ptr - pointer to new message buffer
    632           *
    633           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    635          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    636          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    637          #ifdef USE_ICALL
    638            if (destination_task & OSAL_PROXY_ID_FLAG)
    639            {
    640              /* Destination is a proxy task */
    641              osal_msg_hdr_t *hdr = (osal_msg_hdr_t *)msg_ptr - 1;
    642              ICall_EntityID src, dst;
    643          
    644              uint8 taskid = osal_self();
    645              if (taskid == TASK_NO_TASK)
    646              {
    647                /* Call must have been made from either an ISR or a user-thread */
    648                src = osal_notask_entity;
    649              }
    650              else
    651              {
    652                src = (ICall_EntityID) osal_dispatch_entities[taskid + tasksCnt];
    653              }
    654              if (src == OSAL_INVALID_DISPATCH_ID)
    655              {
    656                /* The source entity is not registered */
    657                /* abort */
    658                ICall_abort();
    659                return FAILURE;
    660              }
    661              dst = osal_proxy2alien(destination_task);
    662              hdr->dest_id = TASK_NO_TASK;
    663              if (ICall_send(src, dst, ICALL_MSG_FORMAT_KEEP, msg_ptr) ==
    664                  ICALL_ERRNO_SUCCESS)
    665              {
    666                return SUCCESS;
    667              }
    668              osal_msg_deallocate(msg_ptr);
    669              return FAILURE;
    670            }
    671          #endif /* USE_ICALL */
    672            return ( osal_msg_enqueue_push( destination_task, msg_ptr, FALSE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C00         MOV     R4,#0x0
   \   000007                REQUIRE ?Subroutine5
   \   000007                ; // Fall through to label ?Subroutine5
    673          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ??osal_msg_enqueue_push?relay; Banked call to: osal_msg_enqueue_push
   \   000003   02....       LJMP    ??Subroutine22_0 & 0xFFFF
    674          
    675          /*********************************************************************
    676           * @fn      osal_msg_push_front
    677           *
    678           * @brief
    679           *
    680           *    This function is called by a task to push a command message
    681           *    to the head of the OSAL queue. The destination_task field
    682           *    must refer to a valid task, since the task ID will be used to
    683           *    send the message to. This function will also set a message
    684           *    ready event in the destination task's event list.
    685           *
    686           * @param   uint8 destination_task - Send msg to Task ID
    687           * @param   uint8 *msg_ptr - pointer to message buffer
    688           *
    689           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    690           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    691          uint8 osal_msg_push_front( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_push_front:
    692          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    693            return ( osal_msg_enqueue_push( destination_task, msg_ptr, TRUE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C01         MOV     R4,#0x1
   \   000007   80..         SJMP    ?Subroutine5
    694          }
    695          
    696          /*********************************************************************
    697           * @fn      osal_msg_enqueue_push
    698           *
    699           * @brief
    700           *
    701           *    This function is called by a task to either enqueue (append to
    702           *    queue) or push (prepend to queue) a command message to the OSAL
    703           *    queue. The destination_task field must refer to a valid task,
    704           *    since the task ID will be used to send the message to. This 
    705           *    function will also set a message ready event in the destination
    706           *    task's event list.
    707           *
    708           * @param   uint8 destination_task - Send msg to Task ID
    709           * @param   uint8 *msg_ptr - pointer to message buffer
    710           * @param   uint8 push - TRUE to push, otherwise enqueue
    711           *
    712           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    713           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    714          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 push )
   \                     osal_msg_enqueue_push:
    715          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EC           MOV     A,R4
   \   000008   FF           MOV     R7,A
    716            if ( msg_ptr == NULL )
   \   000009   EA           MOV     A,R2
   \   00000A   4B           ORL     A,R3
   \   00000B   6026         JZ      ??osal_msg_enqueue_push_0
    717            {
    718              return ( INVALID_MSG_POINTER );
    719            }
    720          
    721          #ifdef USE_ICALL
    722            if (destination_task & OSAL_PROXY_ID_FLAG)
    723            {
    724              ICall_abort();
    725            }
    726          #endif /* USE_ICALL */
    727          
    728            if ( destination_task >= tasksCnt )
   \   00000D   90....       MOV     DPTR,#tasksCnt
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   EE           MOV     A,R6
   \   000013   C3           CLR     C
   \   000014   98           SUBB    A,R0
   \   000015   4007         JC      ??osal_msg_enqueue_push_1
    729            {
    730              osal_msg_deallocate( msg_ptr );
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    731              return ( INVALID_TASK );
   \   00001A   7903         MOV     R1,#0x3
   \   00001C   8043         SJMP    ??osal_msg_enqueue_push_2
    732            }
    733          
    734            // Check the message header
    735            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    736                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_enqueue_push_1:
   \   00001E   EA           MOV     A,R2
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   F582         MOV     DPL,A
   \   000023   EB           MOV     A,R3
   \   000024   34FF         ADDC    A,#-0x1
   \   000026   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000029   7005         JNZ     ??osal_msg_enqueue_push_3
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00002E   6007         JZ      ??osal_msg_enqueue_push_4
    737            {
    738              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_enqueue_push_3:
   \   000030                ; Setup parameters for call to function osal_msg_deallocate
   \   000030   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    739              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_enqueue_push_0:
   \   000033   7905         MOV     R1,#0x5
   \   000035   802A         SJMP    ??osal_msg_enqueue_push_2
    740            }
    741          
    742            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_enqueue_push_4:
   \   000037   EE           MOV     A,R6
   \   000038   F0           MOVX    @DPTR,A
    743          
    744            if ( push == TRUE )
   \   000039   7401         MOV     A,#0x1
   \   00003B   6F           XRL     A,R7
   \   00003C   700D         JNZ     ??osal_msg_enqueue_push_5
    745            {
    746              // prepend the message
    747              osal_msg_push( &osal_qHead, msg_ptr );
   \   00003E                ; Setup parameters for call to function osal_msg_push
   \   00003E   EA           MOV     A,R2
   \   00003F   FC           MOV     R4,A
   \   000040   EB           MOV     A,R3
   \   000041   FD           MOV     R5,A
   \   000042   7A..         MOV     R2,#osal_qHead & 0xff
   \   000044   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000046   12....       LCALL   ??osal_msg_push?relay; Banked call to: osal_msg_push
   \   000049   800B         SJMP    ??osal_msg_enqueue_push_6
    748            }
    749            else
    750            {
    751              // append the message
    752              osal_msg_enqueue( &osal_qHead, msg_ptr );
   \                     ??osal_msg_enqueue_push_5:
   \   00004B                ; Setup parameters for call to function osal_msg_enqueue
   \   00004B   EA           MOV     A,R2
   \   00004C   FC           MOV     R4,A
   \   00004D   EB           MOV     A,R3
   \   00004E   FD           MOV     R5,A
   \   00004F   7A..         MOV     R2,#osal_qHead & 0xff
   \   000051   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000053   12....       LCALL   ??osal_msg_enqueue?relay; Banked call to: osal_msg_enqueue
    753            }
    754          
    755            // Signal the task that a message is waiting
    756            osal_set_event( destination_task, SYS_EVENT_MSG );
   \                     ??osal_msg_enqueue_push_6:
   \   000056                ; Setup parameters for call to function osal_set_event
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B80         MOV     R3,#-0x80
   \   00005A   EE           MOV     A,R6
   \   00005B   F9           MOV     R1,A
   \   00005C   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
    757          
    758            return ( SUCCESS );
   \   00005F   7900         MOV     R1,#0x0
   \                     ??osal_msg_enqueue_push_2:
   \   000061   02....       LJMP    ??Subroutine22_0 & 0xFFFF
    759          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine25_0
   \   000002                ; // Fall through to label ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET
    760          
    761          /*********************************************************************
    762           * @fn      osal_msg_receive
    763           *
    764           * @brief
    765           *
    766           *    This function is called by a task to retrieve a received command
    767           *    message. The calling task must deallocate the message buffer after
    768           *    processing the message using the osal_msg_deallocate() call.
    769           *
    770           * @param   uint8 task_id - receiving tasks ID
    771           *
    772           * @return  *uint8 - message information or NULL if no message
    773           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    774          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    775          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
    776            osal_msg_hdr_t *listHdr;
    777            osal_msg_hdr_t *prevHdr = NULL;
   \   000007   75..00       MOV     ?V4,#0x0
   \   00000A   75..00       MOV     ?V5,#0x0
    778            osal_msg_hdr_t *foundHdr = NULL;
   \   00000D   7E00         MOV     R6,#0x0
   \   00000F   7F00         MOV     R7,#0x0
    779            halIntState_t   intState;
    780          
    781            // Hold off interrupts
    782            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   33           RLC     A
   \   000015   F5..         MOV     ?V3,A
   \   000017   C2AF         CLR     0xa8.7
    783          
    784            // Point to the top of the queue
    785            listHdr = osal_qHead;
   \   000019   90....       MOV     DPTR,#osal_qHead
   \   00001C   8015         SJMP    ??CrossCallReturnLabel_27
    786          
    787            // Look through the queue for a message that belongs to the asking task
    788            while ( listHdr != NULL )
    789            {
    790              if ( (listHdr - 1)->dest_id == task_id )
    791              {
    792                if ( foundHdr == NULL )
    793                {
    794                  // Save the first one
    795                  foundHdr = listHdr;
    796                }
    797                else
    798                {
    799                  // Second msg found, stop looking
    800                  break;
    801                }
    802              }
    803              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_0:
   \   00001E   EE           MOV     A,R6
   \   00001F   4F           ORL     A,R7
   \   000020   7006         JNZ     ??osal_msg_receive_1
    804              {
    805                prevHdr = listHdr;
   \   000022   85....       MOV     ?V4,?V0
   \   000025   85....       MOV     ?V5,?V1
    806              }
    807              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_1:
   \   000028   E5..         MOV     A,?V0
   \   00002A   24FB         ADD     A,#-0x5
   \   00002C   F582         MOV     DPL,A
   \   00002E   E5..         MOV     A,?V1
   \   000030   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000033   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000036   E5..         MOV     A,?V0
   \   000038   45..         ORL     A,?V1
   \   00003A   6023         JZ      ??osal_msg_receive_2
   \   00003C   E5..         MOV     A,?V0
   \   00003E   24FF         ADD     A,#-0x1
   \   000040   F582         MOV     DPL,A
   \   000042   E5..         MOV     A,?V1
   \   000044   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000047   E0           MOVX    A,@DPTR
   \   000048   65..         XRL     A,?V2
   \   00004A   70D2         JNZ     ??osal_msg_receive_0
   \   00004C   EE           MOV     A,R6
   \   00004D   4F           ORL     A,R7
   \   00004E   7006         JNZ     ??osal_msg_receive_3
   \   000050   AE..         MOV     R6,?V0
   \   000052   AF..         MOV     R7,?V1
   \   000054   80D2         SJMP    ??osal_msg_receive_1
    808            }
    809          
    810            // Is there more than one?
    811            if ( listHdr != NULL )
    812            {
    813              // Yes, Signal the task that a message is waiting
    814              osal_set_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_3:
   \   000056                ; Setup parameters for call to function osal_set_event
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B80         MOV     R3,#-0x80
   \   00005A   12....       LCALL   ??osal_set_event?relay; Banked call to: osal_set_event
   \   00005D   800B         SJMP    ??osal_msg_receive_4
    815            }
    816            else
    817            {
    818              // No more
    819              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_2:
   \   00005F                ; Setup parameters for call to function osal_clear_event
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B80         MOV     R3,#-0x80
   \   000063   12....       LCALL   ??osal_clear_event?relay; Banked call to: osal_clear_event
    820            }
    821          
    822            // Did we find a message?
    823            if ( foundHdr != NULL )
   \   000066   EE           MOV     A,R6
   \   000067   4F           ORL     A,R7
   \   000068   6015         JZ      ??osal_msg_receive_5
    824            {
    825              // Take out of the link list
    826              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \                     ??osal_msg_receive_4:
   \   00006A                ; Setup parameters for call to function osal_msg_extract
   \   00006A   78..         MOV     R0,#?V4
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   EE           MOV     A,R6
   \   000070   FC           MOV     R4,A
   \   000071   EF           MOV     A,R7
   \   000072   FD           MOV     R5,A
   \   000073   7A..         MOV     R2,#osal_qHead & 0xff
   \   000075   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000077   12....       LCALL   ??osal_msg_extract?relay; Banked call to: osal_msg_extract
   \   00007A   7402         MOV     A,#0x2
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
    827            }
    828          
    829            // Release interrupts
    830            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_5:
   \   00007F   E5..         MOV     A,?V3
   \   000081   A2E0         MOV     C,0xE0 /* A   */.0
   \   000083   92AF         MOV     0xa8.7,C
    831          
    832            return ( (uint8*) foundHdr );
   \   000085   EE           MOV     A,R6
   \   000086   FA           MOV     R2,A
   \   000087   EF           MOV     A,R7
   \   000088   FB           MOV     R3,A
   \   000089   7F06         MOV     R7,#0x6
   \   00008B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00008E                REQUIRE _A_IEN0
    833          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine24_0:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
    834          
    835          /**************************************************************************************************
    836           * @fn          osal_msg_find
    837           *
    838           * @brief       This function finds in place an OSAL message matching the task_id and event
    839           *              parameters.
    840           *
    841           * input parameters
    842           *
    843           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    844           * @param       event - The OSAL event id that the enqueued OSAL message must match.
    845           *
    846           * output parameters
    847           *
    848           * None.
    849           *
    850           * @return      NULL if no match, otherwise an in place pointer to the matching OSAL message.
    851           **************************************************************************************************
    852           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    853          osal_event_hdr_t *osal_msg_find(uint8 task_id, uint8 event)
   \                     osal_msg_find:
    854          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV     A,R2
   \   000005   FC           MOV     R4,A
    855            osal_msg_hdr_t *pHdr;
    856            halIntState_t intState;
    857          
    858            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000006   A2AF         MOV     C,0xa8.7
   \   000008   E4           CLR     A
   \   000009   33           RLC     A
   \   00000A   F8           MOV     R0,A
   \   00000B   C2AF         CLR     0xa8.7
    859          
    860            pHdr = osal_qHead;  // Point to the top of the queue.
   \   00000D   90....       MOV     DPTR,#osal_qHead
   \   000010   8009         SJMP    ??CrossCallReturnLabel_29
    861          
    862            // Look through the queue for a message that matches the task_id and event parameters.
    863            while (pHdr != NULL)
    864            {
    865              if (((pHdr-1)->dest_id == task_id) && (((osal_event_hdr_t *)pHdr)->event == event))
    866              {
    867                break;
    868              }
    869          
    870              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_find_0:
   \   000012   EA           MOV     A,R2
   \   000013   24FB         ADD     A,#-0x5
   \   000015   F582         MOV     DPL,A
   \   000017   EB           MOV     A,R3
   \   000018   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00001B   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001E   EA           MOV     A,R2
   \   00001F   4B           ORL     A,R3
   \   000020   6015         JZ      ??osal_msg_find_1
   \   000022   EA           MOV     A,R2
   \   000023   24FF         ADD     A,#-0x1
   \   000025   F582         MOV     DPL,A
   \   000027   EB           MOV     A,R3
   \   000028   12....       LCALL   ??Subroutine24_0 & 0xFFFF
    871            }
   \                     ??CrossCallReturnLabel_30:
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   69           XRL     A,R1
   \   00002D   70E3         JNZ     ??osal_msg_find_0
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6C           XRL     A,R4
   \   000035   70DB         JNZ     ??osal_msg_find_0
    872          
    873            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \                     ??osal_msg_find_1:
   \   000037   E8           MOV     A,R0
   \   000038   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003A   92AF         MOV     0xa8.7,C
    874          
    875            return (osal_event_hdr_t *)pHdr;
   \   00003C   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   00003F                REQUIRE _A_IEN0
    876          }
    877          
    878          /**************************************************************************************************
    879           * @fn          osal_msg_count
    880           *
    881           * @brief       This function counts the number of messages, in the OSAL message queue with a
    882           *              a given task ID and message event type.
    883           *
    884           * input parameters
    885           *
    886           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    887           * @param       event - The OSAL event id that the enqueued OSAL message must match. 0xFF for 
    888           *              all events.
    889           *
    890           * output parameters
    891           *
    892           * None.
    893           *
    894           * @return      The number of OSAL messages that match the task ID and Event.
    895           **************************************************************************************************
    896           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    897          uint8 osal_msg_count( uint8 task_id, uint8 event )
   \                     osal_msg_count:
    898          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FB           MOV     R3,A
    899            uint8 count = 0;
   \   000007   7900         MOV     R1,#0x0
    900            osal_msg_hdr_t *pHdr;
    901            halIntState_t intState;
    902          
    903            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   C2AF         CLR     0xa8.7
    904          
    905            pHdr = osal_qHead;  // Point to the top of the queue.
   \   000010   90....       MOV     DPTR,#osal_qHead
   \   000013   801B         SJMP    ??CrossCallReturnLabel_35
    906          
    907            // Look through the queue for a message that matches the task_id and event parameters.
    908            while (pHdr != NULL)
    909            {
    910              if ( ((pHdr-1)->dest_id == task_id) 
    911                  && ((event == 0xFF) || (((osal_event_hdr_t *)pHdr)->event == event)) )
   \                     ??osal_msg_count_0:
   \   000015   EC           MOV     A,R4
   \   000016   24FF         ADD     A,#-0x1
   \   000018   12....       LCALL   ??Subroutine23_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6B           XRL     A,R3
   \   00001D   700E         JNZ     ??osal_msg_count_1
   \   00001F   74FF         MOV     A,#-0x1
   \   000021   6A           XRL     A,R2
   \   000022   6008         JZ      ??osal_msg_count_2
   \   000024   8C82         MOV     DPL,R4
   \   000026   8D83         MOV     DPH,R5
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6A           XRL     A,R2
   \   00002A   7001         JNZ     ??osal_msg_count_1
    912              {
    913                count++;
   \                     ??osal_msg_count_2:
   \   00002C   09           INC     R1
    914              }
    915          
    916              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_count_1:
   \   00002D   12....       LCALL   ?Subroutine15 & 0xFFFF
    917            }
   \                     ??CrossCallReturnLabel_35:
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FC           MOV     R4,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FD           MOV     R5,A
   \   000035   EC           MOV     A,R4
   \   000036   4D           ORL     A,R5
   \   000037   70DC         JNZ     ??osal_msg_count_0
    918          
    919            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \   000039   E8           MOV     A,R0
   \   00003A                REQUIRE ?Subroutine4
   \   00003A                REQUIRE _A_IEN0
   \   00003A                ; // Fall through to label ?Subroutine4
    920          
    921            return ( count );
    922          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A2E0         MOV     C,0xE0 /* A   */.0
   \   000002                REQUIRE ??Subroutine21_0
   \   000002                ; // Fall through to label ??Subroutine21_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine21_0:
   \   000000   92AF         MOV     0xa8.7,C
   \   000002   80..         SJMP    ??Subroutine22_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   EC           MOV     A,R4
   \   000001   24FB         ADD     A,#-0x5
   \   000003                REQUIRE ??Subroutine23_0
   \   000003                ; // Fall through to label ??Subroutine23_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine23_0:
   \   000000   F582         MOV     DPL,A
   \   000002   ED           MOV     A,R5
   \   000003                REQUIRE ??Subroutine24_0
   \   000003                ; // Fall through to label ??Subroutine24_0
    923          
    924          /*********************************************************************
    925           * @fn      osal_msg_enqueue
    926           *
    927           * @brief
    928           *
    929           *    This function enqueues an OSAL message into an OSAL queue.
    930           *
    931           * @param   osal_msg_q_t *q_ptr - OSAL queue
    932           * @param   void *msg_ptr  - OSAL message
    933           *
    934           * @return  none
    935           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    936          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    937          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    938            void *list;
    939            halIntState_t intState;
    940          
    941            // Hold off interrupts
    942            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    943          
    944            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00000C   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
    945            // If first message in queue
    946            if ( *q_ptr == NULL )
   \   000013   800C         SJMP    ??osal_msg_enqueue_0
    947            {
    948              *q_ptr = msg_ptr;
    949            }
    950            else
    951            {
    952              // Find end of queue
    953              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_1:
   \   000015   E8           MOV     A,R0
   \   000016   24FB         ADD     A,#-0x5
   \   000018   F8           MOV     R0,A
   \   000019   E9           MOV     A,R1
   \   00001A   34FF         ADDC    A,#-0x1
   \   00001C   F9           MOV     R1,A
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \                     ??osal_msg_enqueue_0:
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000028   70EB         JNZ     ??osal_msg_enqueue_1
    954          
    955              // Add message to end of queue
    956              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   00002A   8A82         MOV     DPL,R2
   \   00002C   8B83         MOV     DPH,R3
   \   00002E   EC           MOV     A,R4
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   ED           MOV     A,R5
   \   000032   F0           MOVX    @DPTR,A
    957            }
    958          
    959            // Re-enable interrupts
    960            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000033   EE           MOV     A,R6
   \   000034   80..         SJMP    ?Subroutine4
   \   000036                REQUIRE _A_IEN0
    961          }
    962          
    963          /*********************************************************************
    964           * @fn      osal_msg_dequeue
    965           *
    966           * @brief
    967           *
    968           *    This function dequeues an OSAL message from an OSAL queue.
    969           *
    970           * @param   osal_msg_q_t *q_ptr - OSAL queue
    971           *
    972           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    973           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    974          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    975          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
    976            void *msg_ptr = NULL;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
    977            halIntState_t intState;
    978          
    979            // Hold off interrupts
    980            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FE           MOV     R6,A
   \   000012   C2AF         CLR     0xa8.7
    981          
    982            if ( *q_ptr != NULL )
   \   000014   8C82         MOV     DPL,R4
   \   000016   8D83         MOV     DPH,R5
   \   000018   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00001B   6032         JZ      ??osal_msg_dequeue_0
    983            {
    984              // Dequeue message
    985              msg_ptr = *q_ptr;
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
    986              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000021   EA           MOV     A,R2
   \   000022   24FB         ADD     A,#-0x5
   \   000024   F8           MOV     R0,A
   \   000025   EB           MOV     A,R3
   \   000026   34FF         ADDC    A,#-0x1
   \   000028   F9           MOV     R1,A
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000030   8C82         MOV     DPL,R4
   \   000032   8D83         MOV     DPH,R5
   \   000034   E5..         MOV     A,?V0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E5..         MOV     A,?V1
   \   00003A   F0           MOVX    @DPTR,A
    987              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   E4           CLR     A
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   F0           MOVX    @DPTR,A
    988              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000043   EA           MOV     A,R2
   \   000044   24FF         ADD     A,#-0x1
   \   000046   F582         MOV     DPL,A
   \   000048   EB           MOV     A,R3
   \   000049   12....       LCALL   ??Subroutine24_0 & 0xFFFF
    989            }
   \                     ??CrossCallReturnLabel_31:
   \   00004C   74FF         MOV     A,#-0x1
   \   00004E   F0           MOVX    @DPTR,A
    990          
    991            // Re-enable interrupts
    992            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_0:
   \   00004F   EE           MOV     A,R6
   \   000050   A2E0         MOV     C,0xE0 /* A   */.0
   \   000052   92AF         MOV     0xa8.7,C
    993          
    994            return msg_ptr;
   \   000054                REQUIRE ?Subroutine2
   \   000054                REQUIRE _A_IEN0
   \   000054                ; // Fall through to label ?Subroutine2
    995          }
    996          
    997          /*********************************************************************
    998           * @fn      osal_msg_push
    999           *
   1000           * @brief
   1001           *
   1002           *    This function pushes an OSAL message to the head of an OSAL
   1003           *    queue.
   1004           *
   1005           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1006           * @param   void *msg_ptr  - OSAL message
   1007           *
   1008           * @return  none
   1009           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1010          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
   1011          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1012            halIntState_t intState;
   1013          
   1014            // Hold off interrupts
   1015            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A8A8         MOV     R0,0xa8+0x0
   \   000007   C2AF         CLR     0xa8.7
   1016          
   1017            // Push message to head of queue
   1018            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FE           MOV     R6,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000015   EE           MOV     A,R6
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   EF           MOV     A,R7
   \   000019   F0           MOVX    @DPTR,A
   1019            *q_ptr = msg_ptr;
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   \   00001E   EC           MOV     A,R4
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   ED           MOV     A,R5
   \   000022   12....       LCALL   ?Subroutine16 & 0xFFFF
   1020          
   1021            // Re-enable interrupts
   1022            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_17:
   \   000025   02....       LJMP    ??Subroutine21_0 & 0xFFFF
   \   000028                REQUIRE _A_IEN0
   1023          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   E8           MOV     A,R0
   \   000002   A2E7         MOV     C,0xE0 /* A   */.7
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000A   22           RET
   1024          
   1025          /*********************************************************************
   1026           * @fn      osal_msg_extract
   1027           *
   1028           * @brief
   1029           *
   1030           *    This function extracts and removes an OSAL message from the
   1031           *    middle of an OSAL queue.
   1032           *
   1033           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1034           * @param   void *msg_ptr  - OSAL message to be extracted
   1035           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
   1036           *
   1037           * @return  none
   1038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1039          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
   1040          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   1041            halIntState_t intState;
   1042          
   1043            // Hold off interrupts
   1044            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   F5..         MOV     ?V2,A
   \   00000B   C2AF         CLR     0xa8.7
   1045          
   1046            if ( msg_ptr == *q_ptr )
   \   00000D   EC           MOV     A,R4
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   F8           MOV     R0,A
   \   000011   ED           MOV     A,R5
   \   000012   34FF         ADDC    A,#-0x1
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   FE           MOV     R6,A
   \   000017   E9           MOV     A,R1
   \   000018   FF           MOV     R7,A
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000029   EC           MOV     A,R4
   \   00002A   65..         XRL     A,?V0
   \   00002C   7003         JNZ     ??osal_msg_extract_0
   \   00002E   ED           MOV     A,R5
   \   00002F   65..         XRL     A,?V1
   \                     ??osal_msg_extract_0:
   \   000031   7006         JNZ     ??osal_msg_extract_1
   1047            {
   1048              // remove from first
   1049              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   8012         SJMP    ??CrossCallReturnLabel_32
   1050            }
   1051            else
   1052            {
   1053              // remove from middle
   1054              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000039   740B         MOV     A,#0xb
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   CA           XCH     A,R2
   \   000043   24FB         ADD     A,#-0x5
   \   000045   F582         MOV     DPL,A
   \   000047   EA           MOV     A,R2
   \   000048   12....       LCALL   ??Subroutine24_0 & 0xFFFF
   1055            }
   \                     ??CrossCallReturnLabel_32:
   \   00004B   E8           MOV     A,R0
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   E9           MOV     A,R1
   \   00004F   F0           MOVX    @DPTR,A
   1056            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E4           CLR     A
   \   000055   F0           MOVX    @DPTR,A
   \   000056   A3           INC     DPTR
   \   000057   F0           MOVX    @DPTR,A
   1057            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000058   EC           MOV     A,R4
   \   000059   24FF         ADD     A,#-0x1
   \   00005B   12....       LCALL   ??Subroutine23_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00005E   74FF         MOV     A,#-0x1
   \   000060   F0           MOVX    @DPTR,A
   1058          
   1059            // Re-enable interrupts
   1060            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000061   E5..         MOV     A,?V2
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   92AF         MOV     0xa8.7,C
   1061          }
   \   000067   7F03         MOV     R7,#0x3
   \   000069   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00006C                REQUIRE _A_IEN0
   1062          
   1063          /*********************************************************************
   1064           * @fn      osal_msg_enqueue_max
   1065           *
   1066           * @brief
   1067           *
   1068           *    This function enqueues an OSAL message into an OSAL queue if
   1069           *    the length of the queue is less than max.
   1070           *
   1071           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1072           * @param   void *msg_ptr  - OSAL message
   1073           * @param   uint8 max - maximum length of queue
   1074           *
   1075           * @return  TRUE if message was enqueued, FALSE otherwise
   1076           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1077          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
   1078          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FE           MOV     R6,A
   1079            void *list;
   1080            uint8 ret = FALSE;
   \   00000B   7A00         MOV     R2,#0x0
   1081            halIntState_t intState;
   1082          
   1083            // Hold off interrupts
   1084            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FB           MOV     R3,A
   \   000012   C2AF         CLR     0xa8.7
   1085          
   1086            // If first message in queue
   1087            if ( *q_ptr == NULL )
   \   000014   85..82       MOV     DPL,?V0
   \   000017   85..83       MOV     DPH,?V1
   \   00001A   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00001D   7005         JNZ     ??osal_msg_enqueue_max_0
   1088            {
   1089              *q_ptr = msg_ptr;
   \   00001F   801A         SJMP    ??osal_msg_enqueue_max_1
   1090              ret = TRUE;
   1091            }
   1092            else
   1093            {
   1094              // Find end of queue or max
   1095              list = *q_ptr;
   1096              max--;
   1097              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
   \                     ??osal_msg_enqueue_max_2:
   \   000021   EE           MOV     A,R6
   \   000022   6024         JZ      ??osal_msg_enqueue_max_3
   1098              {
   1099                list = OSAL_MSG_NEXT( list );
   1100                max--;
   \                     ??osal_msg_enqueue_max_0:
   \   000024   1E           DEC     R6
   1101              }
   \   000025   E8           MOV     A,R0
   \   000026   24FB         ADD     A,#-0x5
   \   000028   F8           MOV     R0,A
   \   000029   E9           MOV     A,R1
   \   00002A   34FF         ADDC    A,#-0x1
   \   00002C   F9           MOV     R1,A
   \   00002D   88..         MOV     ?V0,R0
   \   00002F   89..         MOV     ?V1,R1
   \   000031   8882         MOV     DPL,R0
   \   000033   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000036   70E9         JNZ     ??osal_msg_enqueue_max_2
   1102          
   1103              // Add message to end of queue if max not reached
   1104              if ( max != 0 )
   \   000038   EE           MOV     A,R6
   \   000039   600D         JZ      ??osal_msg_enqueue_max_3
   1105              {
   1106                OSAL_MSG_NEXT( list ) = msg_ptr;
   \                     ??osal_msg_enqueue_max_1:
   \   00003B   85..82       MOV     DPL,?V0
   \   00003E   85..83       MOV     DPH,?V1
   \   000041   EC           MOV     A,R4
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   ED           MOV     A,R5
   \   000045   F0           MOVX    @DPTR,A
   1107                ret = TRUE;
   \   000046   7A01         MOV     R2,#0x1
   1108              }
   1109            }
   1110          
   1111            // Re-enable interrupts
   1112            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_3:
   \   000048   EB           MOV     A,R3
   \   000049   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004B   92AF         MOV     0xa8.7,C
   1113          
   1114            return ret;
   \   00004D   EA           MOV     A,R2
   \   00004E   F9           MOV     R1,A
   \   00004F   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   000052                REQUIRE _A_IEN0
   1115          }
   1116          
   1117          /*********************************************************************
   1118           * @fn      osal_set_event
   1119           *
   1120           * @brief
   1121           *
   1122           *    This function is called to set the event flags for a task. The
   1123           *    event passed in is OR'd into the task's event variable.
   1124           *
   1125           * @param   uint8 task_id - receiving tasks ID
   1126           * @param   uint8 event_flag - what event to set
   1127           *
   1128           * @return  SUCCESS, MSG_BUFFER_NOT_AVAIL, FAILURE, INVALID_TASK
   1129           */
   1130          #ifdef OSAL_PORT2TIRTOS
   1131          uint8 osal_set_event_raw( uint8 task_id, uint16 event_flag )
   1132          #else /* OSAL_PORT2TIRTOS */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1133          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
   1134          #endif /* OSAL_PORT2TIRTOS */
   1135          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1136          #ifdef USE_ICALL
   1137            if (task_id & OSAL_PROXY_ID_FLAG)
   1138            {
   1139              /* Destination is a proxy task */
   1140              osal_msg_hdr_t *hdr;
   1141              ICall_EntityID src, dst;
   1142              uint8 taskid;
   1143          
   1144              struct _osal_event_msg_t
   1145              {
   1146                uint16 signature;
   1147                uint16 event_flag;
   1148              } *msg_ptr = (struct _osal_event_msg_t *)
   1149                osal_msg_allocate(sizeof(*msg_ptr));
   1150          
   1151              if (!msg_ptr)
   1152              {
   1153                return MSG_BUFFER_NOT_AVAIL;
   1154              }
   1155              msg_ptr->signature = 0xffffu;
   1156              msg_ptr->event_flag = event_flag;
   1157              hdr = (osal_msg_hdr_t *)msg_ptr - 1;
   1158          
   1159              taskid = osal_self();
   1160              if (taskid == TASK_NO_TASK)
   1161              {
   1162                /* Call must have been made from either an ISR or a user-thread */
   1163                src = osal_notask_entity;
   1164              }
   1165              else
   1166              {
   1167                src = (ICall_EntityID) osal_dispatch_entities[taskid + tasksCnt];
   1168              }
   1169          
   1170              if (src == OSAL_INVALID_DISPATCH_ID)
   1171              {
   1172                /* The source entity is not registered */
   1173                osal_msg_deallocate((uint8 *) msg_ptr);
   1174                ICall_abort();
   1175                return FAILURE;
   1176              }
   1177              dst = osal_proxy2alien(task_id);
   1178              hdr->dest_id = TASK_NO_TASK;
   1179              if (ICall_send(src, dst,
   1180                             ICALL_MSG_FORMAT_KEEP, msg_ptr) ==
   1181                  ICALL_ERRNO_SUCCESS)
   1182              {
   1183                return SUCCESS;
   1184              }
   1185              osal_msg_deallocate((uint8 *) msg_ptr);
   1186              return FAILURE;
   1187            }
   1188          #endif /* USE_ICALL */
   1189          
   1190            if ( task_id < tasksCnt )
   \   000007   90....       MOV     DPTR,#tasksCnt
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   EE           MOV     A,R6
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   502D         JNC     ??osal_set_event_0
   1191            {
   1192              halIntState_t   intState;
   1193              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000011   ACA8         MOV     R4,0xa8+0x0
   \   000013   C2AF         CLR     0xa8.7
   1194              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000015   EE           MOV     A,R6
   \   000016   29           ADD     A,R1
   \   000017   F8           MOV     R0,A
   \   000018   E4           CLR     A
   \   000019   33           RLC     A
   \   00001A   F9           MOV     R1,A
   \   00001B   90....       MOV     DPTR,#tasksEvents
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   28           ADD     A,R0
   \   000020   FD           MOV     R5,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   39           ADDC    A,R1
   \   000024   8D82         MOV     DPL,R5
   \   000026   F583         MOV     DPH,A
   \   000028   E0           MOVX    A,@DPTR
   \   000029   4A           ORL     A,R2
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   4B           ORL     A,R3
   \   00002E   F0           MOVX    @DPTR,A
   1195              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00002F   EC           MOV     A,R4
   \   000030   A2E7         MOV     C,0xE0 /* A   */.7
   \   000032   E4           CLR     A
   \   000033   33           RLC     A
   \   000034   F8           MOV     R0,A
   \   000035   EC           MOV     A,R4
   \   000036   A2E7         MOV     C,0xE0 /* A   */.7
   \   000038   92AF         MOV     0xa8.7,C
   1196          #ifdef USE_ICALL
   1197              ICall_signal(osal_semaphore);
   1198          #endif /* USE_ICALL */
   1199              return ( SUCCESS );
   \   00003A   7900         MOV     R1,#0x0
   \   00003C   8002         SJMP    ??osal_set_event_1
   1200            }
   1201             else
   1202            {
   1203              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   00003E   7903         MOV     R1,#0x3
   1204            }
   \                     ??osal_set_event_1:
   \   000040   02....       LJMP    ??Subroutine22_0 & 0xFFFF
   \   000043                REQUIRE _A_IEN0
   1205          }
   1206          
   1207          /*********************************************************************
   1208           * @fn      osal_clear_event
   1209           *
   1210           * @brief
   1211           *
   1212           *    This function is called to clear the event flags for a task. The
   1213           *    event passed in is masked out of the task's event variable.
   1214           *
   1215           * @param   uint8 task_id - receiving tasks ID
   1216           * @param   uint8 event_flag - what event to clear
   1217           *
   1218           * @return  SUCCESS, INVALID_TASK
   1219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1220          uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
   1221          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   1222            if ( task_id < tasksCnt )
   \   000007   90....       MOV     DPTR,#tasksCnt
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   EF           MOV     A,R7
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   5027         JNC     ??osal_clear_event_0
   1223            {
   1224              halIntState_t   intState;
   1225              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000011   AEA8         MOV     R6,0xa8+0x0
   \   000013   C2AF         CLR     0xa8.7
   1226              tasksEvents[task_id] &= ~(event_flag);   // Clear the event bit(s)
   \   000015   EA           MOV     A,R2
   \   000016   F4           CPL     A
   \   000017   FC           MOV     R4,A
   \   000018   EB           MOV     A,R3
   \   000019   F4           CPL     A
   \   00001A   FD           MOV     R5,A
   \   00001B   EF           MOV     A,R7
   \   00001C   29           ADD     A,R1
   \   00001D   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000020   F583         MOV     DPH,A
   \   000022   E0           MOVX    A,@DPTR
   \   000023   5C           ANL     A,R4
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   5D           ANL     A,R5
   \   000028   F0           MOVX    @DPTR,A
   1227              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   000029   EE           MOV     A,R6
   \   00002A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002C   E4           CLR     A
   \   00002D   33           RLC     A
   \   00002E   F8           MOV     R0,A
   \   00002F   EE           MOV     A,R6
   \   000030   A2E7         MOV     C,0xE0 /* A   */.7
   \   000032   92AF         MOV     0xa8.7,C
   1228              return ( SUCCESS );
   \   000034   7900         MOV     R1,#0x0
   \   000036   8002         SJMP    ??osal_clear_event_1
   1229            }
   1230             else
   1231            {
   1232              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   000038   7903         MOV     R1,#0x3
   1233            }
   \                     ??osal_clear_event_1:
   \   00003A   02....       LJMP    ??Subroutine22_0 & 0xFFFF
   \   00003D                REQUIRE _A_IEN0
   1234          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   33           RLC     A
   \   000003   F9           MOV     R1,A
   \   000004   90....       MOV     DPTR,#tasksEvents
   \   000007   E0           MOVX    A,@DPTR
   \   000008   28           ADD     A,R0
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   39           ADDC    A,R1
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   22           RET
   1235          
   1236          /*********************************************************************
   1237           * @fn      osal_isr_register
   1238           *
   1239           * @brief
   1240           *
   1241           *   This function is called to register a service routine with an
   1242           *   interrupt. When the interrupt occurs, this service routine is called.
   1243           *
   1244           * @param   uint8 interrupt_id - Interrupt number
   1245           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
   1246           *
   1247           * @return  SUCCESS, INVALID_INTERRUPT_ID,
   1248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1249          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
   1250          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1251            // Remove these statements when functionality is complete
   1252            (void)interrupt_id;
   1253            (void)isr_ptr;
   1254            return ( SUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
   1255          }
   1256          
   1257          /*********************************************************************
   1258           * @fn      osal_int_enable
   1259           *
   1260           * @brief
   1261           *
   1262           *   This function is called to enable an interrupt. Once enabled,
   1263           *   occurrence of the interrupt causes the service routine associated
   1264           *   with that interrupt to be called.
   1265           *
   1266           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
   1267           *   If a single interrupt is passed in, then interrupts still have
   1268           *   to be enabled with another call to INTS_ALL.
   1269           *
   1270           * @param   uint8 interrupt_id - Interrupt number
   1271           *
   1272           * @return  SUCCESS or INVALID_INTERRUPT_ID
   1273           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1274          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
   1275          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
   1276          
   1277            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV     A,#-0x1
   \   000004   68           XRL     A,R0
   \   000005   7006         JNZ     ??osal_int_enable_0
   1278            {
   1279              HAL_ENABLE_INTERRUPTS();
   \   000007   D2AF         SETB    0xa8.7
   1280              return ( SUCCESS );
   \   000009   7900         MOV     R1,#0x0
   \   00000B   8002         SJMP    ??osal_int_enable_1
   1281            }
   1282            else
   1283            {
   1284              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000D   7907         MOV     R1,#0x7
   \                     ??osal_int_enable_1:
   \   00000F   02....       LJMP    ?BRET
   \   000012                REQUIRE _A_IEN0
   1285            }
   1286          }
   1287          
   1288          /*********************************************************************
   1289           * @fn      osal_int_disable
   1290           *
   1291           * @brief
   1292           *
   1293           *   This function is called to disable an interrupt. When a disabled
   1294           *   interrupt occurs, the service routine associated with that
   1295           *   interrupt is not called.
   1296           *
   1297           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
   1298           *   If a single interrupt is passed in, then just that interrupt is disabled.
   1299           *
   1300           * @param   uint8 interrupt_id - Interrupt number
   1301           *
   1302           * @return  SUCCESS or INVALID_INTERRUPT_ID
   1303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1304          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
   1305          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
   1306          
   1307            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV     A,#-0x1
   \   000004   68           XRL     A,R0
   \   000005   7006         JNZ     ??osal_int_disable_0
   1308            {
   1309              HAL_DISABLE_INTERRUPTS();
   \   000007   C2AF         CLR     0xa8.7
   1310              return ( SUCCESS );
   \   000009   7900         MOV     R1,#0x0
   \   00000B   8002         SJMP    ??osal_int_disable_1
   1311            }
   1312            else
   1313            {
   1314              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000D   7907         MOV     R1,#0x7
   \                     ??osal_int_disable_1:
   \   00000F   02....       LJMP    ?BRET
   \   000012                REQUIRE _A_IEN0
   1315            }
   1316          }
   1317          
   1318          /*********************************************************************
   1319           * @fn      osal_init_system
   1320           *
   1321           * @brief
   1322           *
   1323           *   This function initializes the "task" system by creating the
   1324           *   tasks defined in the task table (OSAL_Tasks.h).
   1325           *
   1326           * @param   void
   1327           *
   1328           * @return  SUCCESS
   1329           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1330          uint8 osal_init_system( void )
   \                     osal_init_system:
   1331          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1332          #if !defined USE_ICALL && !defined OSAL_PORT2TIRTOS
   1333            // Initialize the Memory Allocation System
   1334            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   ??osal_mem_init?relay; Banked call to: osal_mem_init
   1335          #endif /* !defined USE_ICALL && !defined OSAL_PORT2TIRTOS */
   1336          
   1337            // Initialize the message queue
   1338            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
   1339          
   1340            // Initialize the timers
   1341            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   ??osalTimerInit?relay; Banked call to: osalTimerInit
   1342          
   1343            // Initialize the Power Management System
   1344            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   ??osal_pwrmgr_init?relay; Banked call to: osal_pwrmgr_init
   1345          
   1346          #ifdef USE_ICALL
   1347            /* Prepare memory space for service enrollment */
   1348            osal_prepare_svc_enroll();
   1349          #endif /* USE_ICALL */
   1350          
   1351            // Initialize the system tasks.
   1352            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   ??osalInitTasks?relay; Banked call to: osalInitTasks
   1353          
   1354          #if !defined USE_ICALL && !defined OSAL_PORT2TIRTOS
   1355            // Setup efficient search for the first free block of heap.
   1356            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   ??osal_mem_kick?relay; Banked call to: osal_mem_kick
   1357          #endif /* !defined USE_ICALL && !defined OSAL_PORT2TIRTOS */
   1358          
   1359          #ifdef USE_ICALL
   1360            // Initialize variables used to track timing and provide OSAL timer service
   1361            osal_last_timestamp = (uint_least32_t) ICall_getTicks();
   1362            osal_tickperiod = (uint_least32_t) ICall_getTickPeriod();
   1363            osal_max_msecs = (uint_least32_t) ICall_getMaxMSecs();
   1364            /* Reduce ceiling considering potential latency */
   1365            osal_max_msecs -= 2;
   1366          #endif /* USE_ICALL */
   1367          
   1368            return ( SUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   02....       LJMP    ?Subroutine0 & 0xFFFF
   1369          }
   1370          
   1371          /*********************************************************************
   1372           * @fn      osal_start_system
   1373           *
   1374           * @brief
   1375           *
   1376           *   This function is the main loop function of the task system (if
   1377           *   ZBIT and UBIT are not defined). This Function doesn't return.
   1378           *
   1379           * @param   void
   1380           *
   1381           * @return  none
   1382           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1383          void osal_start_system( void )
   \                     osal_start_system:
   1384          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1385          #ifdef USE_ICALL
   1386            /* Kick off timer service in order to allocate resources upfront.
   1387             * The first timeout is required to schedule next OSAL timer event
   1388             * as well. */
   1389            ICall_Errno errno = ICall_setTimer(1, osal_msec_timer_cback,
   1390                                               (void *) osal_msec_timer_seq,
   1391                                               &osal_timerid_msec_timer);
   1392            if (errno != ICALL_ERRNO_SUCCESS)
   1393            {
   1394              ICall_abort();
   1395            }
   1396          #endif /* USE_ICALL */
   1397          
   1398          #if !defined ( ZBIT ) && !defined ( UBIT )
   1399            for(;;)  // Forever Loop
   1400          #endif
   1401            {
   1402              osal_run_system();
   \                     ??osal_start_system_0:
   \   000004                ; Setup parameters for call to function osal_run_system
   \   000004   12....       LCALL   ??osal_run_system?relay; Banked call to: osal_run_system
   \   000007   80FB         SJMP    ??osal_start_system_0
   1403          
   1404          #ifdef USE_ICALL
   1405              ICall_wait(ICALL_TIMEOUT_FOREVER);
   1406          #endif /* USE_ICALL */
   1407            }
   1408          }
   1409          
   1410          #ifdef USE_ICALL
   1411          /*********************************************************************
   1412           * @fn      osal_alien2proxy
   1413           *
   1414           * @brief
   1415           *
   1416           *   Assign or retrieve a proxy OSAL task id for an external ICall entity.
   1417           *
   1418           * @param   origid  ICall entity id
   1419           *
   1420           * @return  proxy OSAL task id
   1421           */
   1422          static uint8 osal_alien2proxy(ICall_EntityID origid)
   1423          {
   1424            size_t i;
   1425          
   1426            for (i = 0; i < OSAL_MAX_NUM_PROXY_TASKS; i++)
   1427            {
   1428              if (osal_proxy_tasks[i] == OSAL_INVALID_DISPATCH_ID)
   1429              {
   1430                /* proxy not found. Create a new one */
   1431                osal_proxy_tasks[i] = (uint8) origid;
   1432                return (OSAL_PROXY_ID_FLAG | i);
   1433              }
   1434              else if ((ICall_EntityID) osal_proxy_tasks[i] == origid)
   1435              {
   1436                return (OSAL_PROXY_ID_FLAG | i);
   1437              }
   1438            }
   1439            /* abort */
   1440            ICall_abort();
   1441            return TASK_NO_TASK;
   1442          }
   1443          
   1444          /*********************************************************************
   1445           * @fn      osal_proxy2alien
   1446           *
   1447           * @brief
   1448           *
   1449           *   Retrieve the ICall entity id for a proxy OSAL task id
   1450           *
   1451           * @param   proxyid  Proxy OSAL task id
   1452           *
   1453           * @return  ICall entity id
   1454           */
   1455          static ICall_EntityID osal_proxy2alien(uint8 proxyid)
   1456          {
   1457            proxyid ^= OSAL_PROXY_ID_FLAG;
   1458            if (proxyid >= OSAL_MAX_NUM_PROXY_TASKS)
   1459            {
   1460              /* abort */
   1461              ICall_abort();
   1462            }
   1463            return (ICall_EntityID) osal_proxy_tasks[proxyid];
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      osal_dispatch2id
   1468           *
   1469           * @brief
   1470           *
   1471           *   Retrieve OSAL task id mapped to a designated ICall entity id
   1472           *
   1473           * @param   entity  ICall entity id
   1474           *
   1475           * @return  OSAL task id
   1476           */
   1477          static uint8 osal_dispatch2id(ICall_EntityID entity)
   1478          {
   1479            size_t i;
   1480          
   1481            for (i = 0; i < tasksCnt; i++)
   1482            {
   1483              if ((ICall_EntityID) osal_dispatch_entities[i] == entity)
   1484              {
   1485                return i;
   1486              }
   1487            }
   1488            return TASK_NO_TASK;
   1489          }
   1490          
   1491          /*********************************************************************
   1492           * @fn      osal_msec_timer_cback
   1493           *
   1494           * @brief
   1495           *
   1496           *   This function is a callback function for ICall_setTimer() service
   1497           *   used to implement OSAL timer
   1498           *
   1499           * @param   arg  In this case, the timer sequence number is passed.
   1500           *
   1501           * @return  None
   1502           */
   1503          static void osal_msec_timer_cback(void *arg)
   1504          {
   1505            unsigned seq = (unsigned) arg;
   1506            halIntState_t intState;
   1507          
   1508            HAL_ENTER_CRITICAL_SECTION(intState);
   1509            if (seq == osal_msec_timer_seq)
   1510            {
   1511              ICall_signal(osal_semaphore);
   1512            }
   1513            HAL_EXIT_CRITICAL_SECTION(intState);
   1514          }
   1515          
   1516          /*********************************************************************
   1517           * @fn      osal_service_entry
   1518           *
   1519           * @brief
   1520           *
   1521           *   This function is service function for messaging service
   1522           *
   1523           * @param   args  arguments.
   1524           *
   1525           * @return  ICall error code
   1526           */
   1527          ICall_Errno osal_service_entry(ICall_FuncArgsHdr *args)
   1528          {
   1529            if (args->func == ICALL_MSG_FUNC_GET_LOCAL_MSG_ENTITY_ID)
   1530            {
   1531              /* Get proxy ID */
   1532              ((ICall_GetLocalMsgEntityIdArgs *)args)->localId =
   1533                osal_alien2proxy(((ICall_GetLocalMsgEntityIdArgs *)args)->entity);
   1534              if (((ICall_GetLocalMsgEntityIdArgs *)args)->localId == TASK_NO_TASK)
   1535              {
   1536                return ICALL_ERRNO_NO_RESOURCE;
   1537              }
   1538            }
   1539            else
   1540            {
   1541              return ICALL_ERRNO_INVALID_FUNCTION;
   1542            }
   1543            return ICALL_ERRNO_SUCCESS;
   1544          }
   1545          #endif /* USE_ICALL */
   1546          
   1547          /*********************************************************************
   1548           * @fn      osal_run_system
   1549           *
   1550           * @brief
   1551           *
   1552           *   This function will make one pass through the OSAL taskEvents table
   1553           *   and call the task_event_processor() function for the first task that
   1554           *   is found with at least one event pending. If there are no pending
   1555           *   events (all tasks), this function puts the processor into Sleep.
   1556           *
   1557           * @param   void
   1558           *
   1559           * @return  none
   1560           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1561          void osal_run_system( void )
   \                     osal_run_system:
   1562          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1563            uint8 idx = 0;
   \   000005   75..00       MOV     ?V0,#0x0
   1564          
   1565          #ifdef USE_ICALL
   1566            uint32 next_timeout_prior = osal_next_timeout();
   1567          #else /* USE_ICALL */
   1568          #ifndef HAL_BOARD_CC2538
   1569            osalTimeUpdate();
   \   000008                ; Setup parameters for call to function osalTimeUpdate
   \   000008   12....       LCALL   ??osalTimeUpdate?relay; Banked call to: osalTimeUpdate
   1570          #endif
   1571          
   1572            Hal_ProcessPoll();
   \   00000B                ; Setup parameters for call to function Hal_ProcessPoll
   \   00000B   12....       LCALL   ??Hal_ProcessPoll?relay; Banked call to: Hal_ProcessPoll
   1573          #endif /* USE_ICALL */
   1574          
   1575          #ifdef USE_ICALL
   1576            {
   1577              /* Update osal timers to the latest before running any OSAL processes
   1578               * regardless of wakeup callback from ICall because OSAL timers are added
   1579               * relative to the current time. */
   1580              unsigned long newtimestamp = ICall_getTicks();
   1581              uint32 milliseconds;
   1582          
   1583              if (osal_tickperiod == 1000)
   1584              {
   1585                milliseconds = newtimestamp - osal_last_timestamp;
   1586                osal_last_timestamp = newtimestamp;
   1587              }
   1588              else
   1589              {
   1590                unsigned long long delta = (unsigned long long)
   1591                  ((newtimestamp - osal_last_timestamp) & 0xfffffffful);
   1592                delta *= osal_tickperiod;
   1593                delta /= 1000;
   1594                milliseconds = (uint32) delta;
   1595                osal_last_timestamp += (uint32) (delta * 1000 / osal_tickperiod);
   1596              }
   1597              osalAdjustTimer(milliseconds);
   1598              /* Set a value that will never match osal_next_timeout()
   1599               * return value so that the next time can be scheduled.
   1600               */
   1601              next_timeout_prior = 0xfffffffful;
   1602            }
   1603            if (osal_eventloop_hook)
   1604            {
   1605              osal_eventloop_hook();
   1606            }
   1607          
   1608            for (;;)
   1609            {
   1610              void *msg;
   1611              ICall_EntityID src, dst;
   1612              osal_msg_hdr_t *hdr;
   1613              uint8 dest_id;
   1614          
   1615              if (ICall_fetchMsg(&src, &dst, &msg) != ICALL_ERRNO_SUCCESS)
   1616              {
   1617                break;
   1618              }
   1619              hdr = (osal_msg_hdr_t *) msg - 1;
   1620              dest_id = osal_dispatch2id(dst);
   1621              if (dest_id == TASK_NO_TASK)
   1622              {
   1623                /* Something wrong */
   1624                ICall_abort();
   1625              }
   1626              else
   1627              {
   1628                /* Message towards one of the tasks */
   1629                /* Create a proxy task ID if necessary and
   1630                 * queue the message to the OSAL internal queue.
   1631                 */
   1632                uint8 proxyid = osal_alien2proxy(hdr->srcentity);
   1633          
   1634                if (hdr->format == ICALL_MSG_FORMAT_1ST_CHAR_TASK_ID)
   1635                {
   1636                  uint8 *bytes = msg;
   1637                  *bytes = proxyid;
   1638                }
   1639                else if (hdr->format == ICALL_MSG_FORMAT_3RD_CHAR_TASK_ID)
   1640                {
   1641                  uint8 *bytes = msg;
   1642                  bytes[2] = proxyid;
   1643                }
   1644                /* now queue the message to the OSAL queue */
   1645                osal_msg_send(dest_id, msg);
   1646              }
   1647            }
   1648          #endif /* USE_ICALL */
   1649          
   1650            do {
   1651              if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_run_system_0:
   \   00000E   A8..         MOV     R0,?V0
   \   000010   E8           MOV     A,R0
   \   000011   28           ADD     A,R0
   \   000012   12....       LCALL   ?Subroutine13 & 0xFFFF
   1652              {
   1653                break;
   1654              }
   1655            } while (++idx < tasksCnt);
   \                     ??CrossCallReturnLabel_14:
   \   000015   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000018   700D         JNZ     ??osal_run_system_1
   \   00001A   05..         INC     ?V0
   \   00001C   90....       MOV     DPTR,#tasksCnt
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F8           MOV     R0,A
   \   000021   E5..         MOV     A,?V0
   \   000023   C3           CLR     C
   \   000024   98           SUBB    A,R0
   \   000025   40E7         JC      ??osal_run_system_0
   1656          
   1657            if (idx < tasksCnt)
   \                     ??osal_run_system_1:
   \   000027   90....       MOV     DPTR,#tasksCnt
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   E5..         MOV     A,?V0
   \   00002E   C3           CLR     C
   \   00002F   98           SUBB    A,R0
   \   000030   506C         JNC     ??osal_run_system_2
   1658            {
   1659              uint16 events;
   1660              halIntState_t intState;
   1661          
   1662              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000032   ACA8         MOV     R4,0xa8+0x0
   \   000034   C2AF         CLR     0xa8.7
   1663              events = tasksEvents[idx];
   \   000036   AE..         MOV     R6,?V0
   \   000038   EE           MOV     A,R6
   \   000039   2E           ADD     A,R6
   \   00003A   FE           MOV     R6,A
   \   00003B   E4           CLR     A
   \   00003C   33           RLC     A
   \   00003D   FF           MOV     R7,A
   \   00003E   90....       MOV     DPTR,#tasksEvents
   \   000041   E0           MOVX    A,@DPTR
   \   000042   2E           ADD     A,R6
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   3F           ADDC    A,R7
   \   000047   F9           MOV     R1,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   1664              tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_55:
   \   00004F   8882         MOV     DPL,R0
   \   000051   8983         MOV     DPH,R1
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   F0           MOVX    @DPTR,A
   1665              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000057   EC           MOV     A,R4
   \   000058   A2E7         MOV     C,0xE0 /* A   */.7
   \   00005A   E4           CLR     A
   \   00005B   33           RLC     A
   \   00005C   F5..         MOV     ?V1,A
   \   00005E   EC           MOV     A,R4
   \   00005F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000061   92AF         MOV     0xa8.7,C
   1666          
   1667              activeTaskID = idx;
   \   000063   E5..         MOV     A,?V0
   \   000065   90....       MOV     DPTR,#activeTaskID
   \   000068   F0           MOVX    @DPTR,A
   1668              events = (tasksArr[idx])( idx, events );
   \   000069                ; Setup parameters for indirect call
   \   000069   F9           MOV     R1,A
   \   00006A   74..         MOV     A,#tasksArr & 0xff
   \   00006C   2E           ADD     A,R6
   \   00006D   F582         MOV     DPL,A
   \   00006F   74..         MOV     A,#(tasksArr >> 8) & 0xff
   \   000071   3F           ADDC    A,R7
   \   000072   F583         MOV     DPH,A
   \   000074   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000077   12....       LCALL   ?CALL_IND
   1669              activeTaskID = TASK_NO_TASK;
   \   00007A   90....       MOV     DPTR,#activeTaskID
   \   00007D   74FF         MOV     A,#-0x1
   \   00007F   F0           MOVX    @DPTR,A
   1670          
   1671              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000080   A8A8         MOV     R0,0xa8+0x0
   \   000082   C2AF         CLR     0xa8.7
   1672              tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000084   90....       MOV     DPTR,#tasksEvents
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2E           ADD     A,R6
   \   000089   F9           MOV     R1,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   3F           ADDC    A,R7
   \   00008D   8982         MOV     DPL,R1
   \   00008F   F583         MOV     DPH,A
   \   000091   E0           MOVX    A,@DPTR
   \   000092   4A           ORL     A,R2
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   4B           ORL     A,R3
   \   000097   12....       LCALL   ?Subroutine16 & 0xFFFF
   1673              HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_18:
   \   00009A   92AF         MOV     0xa8.7,C
   \   00009C   8003         SJMP    ??osal_run_system_3
   1674            }
   1675          #if defined( POWER_SAVING ) && !defined(USE_ICALL)
   1676            else  // Complete pass through all task events with no activity?
   1677            {  
   1678              osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
   \                     ??osal_run_system_2:
   \   00009E                ; Setup parameters for call to function osal_pwrmgr_powerconserve
   \   00009E   12....       LCALL   ??osal_pwrmgr_powerconserve?relay; Banked call to: osal_pwrmgr_powerconserve
   1679            }
   1680          #endif
   1681          
   1682            /* Yield in case cooperative scheduling is being used. */
   1683          #if defined (configUSE_PREEMPTION) && (configUSE_PREEMPTION == 0)
   1684            {
   1685              osal_task_yield();
   1686            }
   1687          #endif
   1688          
   1689          #if defined USE_ICALL
   1690            /* Note that scheduling wakeup at this point instead of
   1691             * scheduling it upon ever OSAL start timer request,
   1692             * would only work if OSAL start timer call is made
   1693             * from OSAL tasks, but not from either ISR or
   1694             * non-OSAL application thread.
   1695             * In case, OSAL start timer is called from non-OSAL
   1696             * task, the scheduling should be part of OSAL_Timers
   1697             * module.
   1698             * Such a change to OSAL_Timers module was not made
   1699             * in order not to diverge the OSAL implementations
   1700             * too drastically between pure OSAL solution vs.
   1701             * OSAL upon service dispatcher (RTOS).
   1702             * TODO: reconsider the above statement.
   1703             */
   1704            {
   1705              halIntState_t intState;
   1706          
   1707              uint32 next_timeout_post = osal_next_timeout();
   1708              if (next_timeout_post != next_timeout_prior)
   1709              {
   1710                /* Next wakeup time has to be scheduled */
   1711                if (next_timeout_post == 0)
   1712                {
   1713                  /* No timer. Set time to the max */
   1714                  next_timeout_post = OSAL_TIMERS_MAX_TIMEOUT;
   1715                }
   1716                if (next_timeout_post > osal_max_msecs)
   1717                {
   1718                  next_timeout_post = osal_max_msecs;
   1719                }
   1720                /* Restart timer */
   1721                HAL_ENTER_CRITICAL_SECTION(intState);
   1722                ICall_stopTimer(osal_timerid_msec_timer);
   1723                ICall_setTimerMSecs(next_timeout_post, osal_msec_timer_cback,
   1724                                    (void *) (++osal_msec_timer_seq),
   1725                                    &osal_timerid_msec_timer);
   1726                HAL_EXIT_CRITICAL_SECTION(intState);
   1727              }
   1728            }
   1729          #endif /* USE_ICALL */
   1730          }
   \                     ??osal_run_system_3:
   \   0000A1   7F04         MOV     R7,#0x4
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000A6                REQUIRE _A_IEN0
   1731          
   1732          /*********************************************************************
   1733           * @fn      osal_buffer_uint32
   1734           *
   1735           * @brief
   1736           *
   1737           *   Buffer an uint32 value - LSB first.
   1738           *
   1739           * @param   buf - buffer
   1740           * @param   val - uint32 value
   1741           *
   1742           * @return  pointer to end of destination buffer
   1743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1744          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
   1745          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V4
   \   00000C   12....       LCALL   ?L_MOV_X
   1746            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   E5..         MOV     A,?V4
   \   000015   12....       LCALL   ?Subroutine17 & 0xFFFF
   1747            *buf++ = BREAK_UINT32( val, 1 );
   1748            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_19:
   \   000018   85....       MOV     ?V0,?V4
   \   00001B   85....       MOV     ?V2,?V6
   \   00001E   85....       MOV     ?V3,?V7
   \   000021   7410         MOV     A,#0x10
   \   000023   78..         MOV     R0,#?V0
   \   000025   12....       LCALL   ?UL_SHR
   \   000028   E5..         MOV     A,?V0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   1749            *buf++ = BREAK_UINT32( val, 3 );
   \   00002C   7418         MOV     A,#0x18
   \   00002E                REQUIRE ?Subroutine3
   \   00002E                ; // Fall through to label ?Subroutine3
   1750          
   1751            return buf;
   1752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   78..         MOV     R0,#?V4
   \   000002   12....       LCALL   ?UL_SHR
   \   000005   E5..         MOV     A,?V4
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   AA82         MOV     R2,DPL
   \   00000B   AB83         MOV     R3,DPH
   \   00000D                REQUIRE ??Subroutine27_0
   \   00000D                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   85....       MOV     ?V1,?V5
   \   000005   E5..         MOV     A,?V1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   22           RET
   1753          
   1754          /*********************************************************************
   1755           * @fn      osal_buffer_uint24
   1756           *
   1757           * @brief
   1758           *
   1759           *   Buffer an uint24 value - LSB first. Note that type uint24 is
   1760           *   typedef to uint32 in comdef.h
   1761           *
   1762           * @param   buf - buffer
   1763           * @param   val - uint24 value
   1764           *
   1765           * @return  pointer to end of destination buffer
   1766           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1767          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
   1768          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V4
   \   00000C   12....       LCALL   ?L_MOV_X
   1769            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   85....       MOV     ?V0,?V4
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   E5..         MOV     A,?V0
   \   000018   12....       LCALL   ?Subroutine17 & 0xFFFF
   1770            *buf++ = BREAK_UINT32( val, 1 );
   1771            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_20:
   \   00001B   7410         MOV     A,#0x10
   \   00001D   80..         SJMP    ?Subroutine3
   1772          
   1773            return buf;
   1774          }
   1775          
   1776          /*********************************************************************
   1777           * @fn      osal_isbufset
   1778           *
   1779           * @brief
   1780           *
   1781           *   Is all of the array elements set to a value?
   1782           *
   1783           * @param   buf - buffer to check
   1784           * @param   val - value to check each array element for
   1785           * @param   len - length to check
   1786           *
   1787           * @return  TRUE if all "val"
   1788           *          FALSE otherwise
   1789           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1790          uint8 osal_isbufset( uint8 *buf, uint8 val, uint8 len )
   \                     osal_isbufset:
   1791          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1792            uint8 x;
   1793          
   1794            if ( buf == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   6018         JZ      ??osal_isbufset_0
   1795            {
   1796              return ( FALSE );
   1797            }
   1798          
   1799            for ( x = 0; x < len; x++ )
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   8001         SJMP    ??osal_isbufset_1
   \                     ??osal_isbufset_2:
   \   00000F   0D           INC     R5
   \                     ??osal_isbufset_1:
   \   000010   ED           MOV     A,R5
   \   000011   C3           CLR     C
   \   000012   9C           SUBB    A,R4
   \   000013   5012         JNC     ??osal_isbufset_3
   1800            {
   1801              // Check for non-initialized value
   1802              if ( buf[x] != val )
   \   000015   ED           MOV     A,R5
   \   000016   F8           MOV     R0,A
   \   000017   EA           MOV     A,R2
   \   000018   28           ADD     A,R0
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   3B           ADDC    A,R3
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   60EC         JZ      ??osal_isbufset_2
   1803              {
   1804                return ( FALSE );
   \                     ??osal_isbufset_0:
   \   000023   7900         MOV     R1,#0x0
   \   000025   8002         SJMP    ??osal_isbufset_4
   1805              }
   1806            }
   1807            return ( TRUE );
   \                     ??osal_isbufset_3:
   \   000027   7901         MOV     R1,#0x1
   \                     ??osal_isbufset_4:
   \   000029   02....       LJMP    ??Subroutine22_0 & 0xFFFF
   1808          }
   1809          
   1810          /*********************************************************************
   1811           * @fn      osal_self
   1812           *
   1813           * @brief
   1814           *
   1815           *   This function returns the task ID of the current (active) task.
   1816           *
   1817           * @param   void
   1818           *
   1819           * @return   active task ID or TASK_NO_TASK if no task is active
   1820           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1821          uint8 osal_self( void )
   \                     osal_self:
   1822          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1823            return ( activeTaskID );
   \   000004   90....       MOV     DPTR,#activeTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF
   1824          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for activeTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_strlen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_revmemcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_revmemcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memdup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memdup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcmp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcmp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_ltoa?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_rand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_allocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_deallocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push_front?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push_front

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_receive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_find?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_find

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_count?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_count

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_dequeue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_extract?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_max?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_clear_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_clear_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isr_register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_disable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_init_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_run_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_run_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint24?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint24

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isbufset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isbufset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_self?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_self

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_1`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_2`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "0">`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5f5e100:
   \   000000   00E1F505     DD 100000000
   1825          
   1826          /*********************************************************************
   1827           */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     59   _ltoa
        0     57   -> _itoa
        0     57   -> strcat
        0     57   -> strcpy
        0     57   -> strlen
      1     20   osal_buffer_uint24
      1     20   osal_buffer_uint32
      2      0   osal_build_uint16
      0     16   osal_build_uint32
      0     23   osal_clear_event
      2      0   osal_init_system
        2      0   -> osalInitTasks
        2      0   -> osalTimerInit
        2      0   -> osal_mem_init
        2      0   -> osal_mem_kick
        2      0   -> osal_pwrmgr_init
      0      0   osal_int_disable
      0      0   osal_int_enable
      0      9   osal_isbufset
      0      0   osal_isr_register
      0     22   osal_memcmp
      1     27   osal_memcpy
      0     18   osal_memdup
        0     15   -> osal_mem_alloc
        0     18   -> osal_memcpy
      0     12   osal_memset
        0     12   -> memset
      0     10   osal_msg_allocate
        0     10   -> osal_mem_alloc
      0      9   osal_msg_count
      2      9   osal_msg_deallocate
        2      0   -> osal_mem_free
      0     10   osal_msg_dequeue
      0     18   osal_msg_enqueue
      0     10   osal_msg_enqueue_max
      1     18   osal_msg_enqueue_push
        0      9   -> osal_msg_deallocate
        0      9   -> osal_msg_enqueue
        0      9   -> osal_msg_push
        0      9   -> osal_set_event
      0     27   osal_msg_extract
      2      0   osal_msg_find
      0     18   osal_msg_push
      0      9   osal_msg_push_front
        0      9   -> osal_msg_enqueue_push
      0     16   osal_msg_receive
        0     14   -> osal_clear_event
        0     16   -> osal_msg_extract
        0     14   -> osal_set_event
      0      9   osal_msg_send
        0      9   -> osal_msg_enqueue_push
      2      0   osal_rand
        2      0   -> Onboard_rand
      1     12   osal_revmemcpy
      0     12   osal_run_system
        0     12   -> Hal_ProcessPoll
        0     12   -> osalTimeUpdate
        0     12   -> osal_pwrmgr_powerconserve
      2      0   osal_self
      0     23   osal_set_event
      2      0   osal_start_system
        2      0   -> osal_run_system
      2      0   osal_strlen
        2      0   -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Constant "">
      10  ?<Constant "">_1
      10  ?<Constant "">_2
       2  ?<Constant "0">
       1  ?<Initializer for activeTaskID>
       4  ??Subroutine21_0
       5  ??Subroutine22_0
       3  ??Subroutine23_0
       5  ??Subroutine24_0
       8  ??Subroutine25_0
       6  ??Subroutine26_0
       5  ??Subroutine27_0
       6  ??_ltoa?relay
       6  ??osal_buffer_uint24?relay
       6  ??osal_buffer_uint32?relay
       6  ??osal_build_uint16?relay
       6  ??osal_build_uint32?relay
       6  ??osal_clear_event?relay
       6  ??osal_init_system?relay
       6  ??osal_int_disable?relay
       6  ??osal_int_enable?relay
       6  ??osal_isbufset?relay
       6  ??osal_isr_register?relay
       6  ??osal_memcmp?relay
       6  ??osal_memcpy?relay
       6  ??osal_memdup?relay
       6  ??osal_memset?relay
       6  ??osal_msg_allocate?relay
       6  ??osal_msg_count?relay
       6  ??osal_msg_deallocate?relay
       6  ??osal_msg_dequeue?relay
       6  ??osal_msg_enqueue?relay
       6  ??osal_msg_enqueue_max?relay
       6  ??osal_msg_enqueue_push?relay
       6  ??osal_msg_extract?relay
       6  ??osal_msg_find?relay
       6  ??osal_msg_push?relay
       6  ??osal_msg_push_front?relay
       6  ??osal_msg_receive?relay
       6  ??osal_msg_send?relay
       6  ??osal_rand?relay
       6  ??osal_revmemcpy?relay
       6  ??osal_run_system?relay
       6  ??osal_self?relay
       6  ??osal_set_event?relay
       6  ??osal_start_system?relay
       6  ??osal_strlen?relay
       7  ?Subroutine0
       4  ?Subroutine1
       8  ?Subroutine10
       9  ?Subroutine11
      15  ?Subroutine12
      16  ?Subroutine13
      13  ?Subroutine14
       3  ?Subroutine15
      11  ?Subroutine16
      10  ?Subroutine17
      15  ?Subroutine18
      21  ?Subroutine19
       5  ?Subroutine2
      14  ?Subroutine20
      13  ?Subroutine3
       2  ?Subroutine4
       6  ?Subroutine5
       3  ?Subroutine6
       2  ?Subroutine7
       8  ?Subroutine8
       6  ?Subroutine9
       1  _A_IEN0
       4  __Constant_2710
       4  __Constant_5f5e100
     616  _ltoa
       1  activeTaskID
      31  osal_buffer_uint24
      46  osal_buffer_uint32
      25  osal_build_uint16
     125  osal_build_uint32
      61  osal_clear_event
      31  osal_init_system
      18  osal_int_disable
      18  osal_int_enable
      44  osal_isbufset
       5  osal_isr_register
     105  osal_memcmp
      43  osal_memcpy
      57  osal_memdup
      31  osal_memset
      81  osal_msg_allocate
      58  osal_msg_count
      34  osal_msg_deallocate
      84  osal_msg_dequeue
      54  osal_msg_enqueue
      82  osal_msg_enqueue_max
     100  osal_msg_enqueue_push
     108  osal_msg_extract
      63  osal_msg_find
      40  osal_msg_push
       9  osal_msg_push_front
     142  osal_msg_receive
       7  osal_msg_send
       2  osal_qHead
       9  osal_rand
      58  osal_revmemcpy
     166  osal_run_system
      12  osal_self
      67  osal_set_event
       9  osal_start_system
      10  osal_strlen

 
 2 676 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    40 bytes in segment XDATA_ROM_C
     2 bytes in segment XDATA_Z
 
 2 887 bytes of CODE  memory
    32 bytes of CONST memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none
